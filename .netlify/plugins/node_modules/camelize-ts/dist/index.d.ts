declare type CamelCase<S extends string> = S extends `${infer P1}_${infer P2}${infer P3}` ? `${P1}${Uppercase<P2>}${CamelCase<P3>}` : S;
declare type CamelizeObject<T, S = false> = {
    [K in keyof T as Uncapitalize<CamelCase<string & K>>]: T[K] extends Date ? T[K] : T[K] extends RegExp ? T[K] : T[K] extends Array<infer U> ? U extends ({} | undefined) ? Array<CamelizeObject<U>> : T[K] : T[K] extends ({} | undefined) ? S extends true ? T[K] : CamelizeObject<T[K]> : T[K];
};
export declare type Camelize<T, S = false> = T extends Array<(infer U)> ? Array<CamelizeObject<U, S>> : CamelizeObject<T, S>;
export default function camelize<T, S extends boolean = false>(
/**
 * Value to be camelized
 */
obj: T, 
/**
 * If true, only the top level keys of the obj will be camel cased
 */
shallow?: S): T extends String ? string : Camelize<T, S>;
export {};
