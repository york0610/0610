import fs from "node:fs/promises";
import path from "node:path";
import YAML from "yaml";
import { ExtensionConfigurationFileSchema, } from "../extension_configuration/schema.js";
import { extensionFilenames } from "../extension_configuration/constants.js";
const resolveConfigurationFilepath = async ({ cwd, }) => {
    for (const filename of extensionFilenames) {
        const resolvedFilepath = path.resolve(cwd, filename);
        try {
            await fs.access(resolvedFilepath, fs.constants.R_OK);
            return resolvedFilepath;
        }
        catch {
            // Continue to next file
        }
    }
    return null;
};
const parseRawConfiguration = (config) => {
    let parsedYAML;
    try {
        parsedYAML = YAML.parse(config);
    }
    catch (err) {
        throw new Error(`Invalid YAML`, { cause: err });
    }
    const result = ExtensionConfigurationFileSchema.safeParse(parsedYAML);
    if (!result.success) {
        throw new Error(`Invalid configuration`, { cause: result.error });
    }
    return result.data.config;
};
const fetchSlugForSite = async ({ id, signal, }) => {
    try {
        const metadataRes = await fetch(`https://api.netlifysdk.com/meta/integration-host-site/${id}`, { signal });
        if (metadataRes.status === 200) {
            return (await metadataRes.json()).slug;
        }
        return null;
    }
    catch {
        return null;
    }
};
/**
 * resolveExtensionConfiguration locates an extension configuration file and loads and parses it.
 * If siteId is specified, or if `process.env.SITE_ID` is non-empty, we'll attempt to load a
 *
 * https://github.com/netlify/jigsaw/blob/ac353af25164239465ed005ed987027308ac2dfa/api/meta.go#L14-L34
 *
 * If a configuration doesn't exist, or if the configuration is invalid, it throws
 */
export const resolveExtensionConfiguration = async ({ cwd, siteId = process.env.SITE_ID ?? "", signal, }) => {
    const configurationFilepath = await resolveConfigurationFilepath({
        cwd,
        signal,
    });
    if (!configurationFilepath) {
        throw new Error(`No Netlify Extension configuration file found in ${cwd}. Add a configuration file named ${extensionFilenames[0]} to the root of your extension.`);
    }
    let raw;
    try {
        raw = await fs.readFile(configurationFilepath, {
            encoding: "utf8",
            signal,
        });
    }
    catch (err) {
        throw new Error(`Unknown error when reading file at ${configurationFilepath}.`, { cause: err });
    }
    let config;
    try {
        config = parseRawConfiguration(raw);
    }
    catch (err) {
        // TODO(ndhoule): We should translate this to a more user-friendly error format
        throw new Error("Invalid Netlify Extension configuration file.", {
            cause: err,
        });
    }
    if (siteId !== "") {
        config.hostSiteId = siteId;
        const slug = await fetchSlugForSite({ id: siteId, signal });
        if (slug !== null) {
            config.slug = slug;
        }
    }
    return config;
};
//# sourceMappingURL=resolve.js.map