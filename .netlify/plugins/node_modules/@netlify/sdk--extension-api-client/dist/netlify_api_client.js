import * as blobs from "@netlify/blobs";
import camelize from "camelize-ts";
import snakeize from "snakify-ts";
import createClient, { wrapAsPathBasedClient, } from "openapi-fetch";
import { default as w } from "wretch";
import { NETLIFY_API_URL } from "./constants.js";
export const DeployContext = {
    All: "all",
    BranchDeploy: "branch-deploy",
    DeployPreview: "deploy-preview",
    Production: "production",
};
export const EnvironmentVariableScope = {
    All: "all",
    Functions: "functions",
    Builds: "builds",
    Runtime: "runtime",
    PostProcessing: "post-processing",
};
/**
 * @internal
 */
export class NetlifyClient {
    apiKey;
    wretch;
    baseURL;
    _client;
    client;
    constructor(apiKey, { baseUrl = "" } = {}) {
        this.apiKey = apiKey;
        this.baseURL = baseUrl !== "" ? baseUrl : NETLIFY_API_URL;
        this._client = createClient({
            baseUrl: this.baseURL.replace(/\/api\/v1\/?$/, ""),
            headers: {
                "Api-Version": "2",
                Authorization: `Bearer ${this.apiKey}`,
                Accept: "application/json",
                "Content-Type": "application/json",
            },
        });
        this.client = wrapAsPathBasedClient(this._client);
        this.wretch = w()
            .url(this.baseURL)
            .auth(`Bearer ${apiKey}`)
            .headers({ "Api-Version": "2" });
    }
    /**
     * getCurrentUser retrieves information about the current authenticated user. If the request is
     * not authenticated, returns null.
     */
    async getCurrentUser() {
        try {
            const res = await this.wretch.url("/user").get().json();
            return {
                id: res.id,
                createdAt: res.created_at,
                avatarUrl: res.avatar_url,
                email: res.email,
                fullName: res.full_name,
            };
        }
        catch {
            return null;
        }
    }
    /**
     * Redeploys a site by triggering a new build. A 'branch' can be specified to build a specific branch. If none are specified, the default branch will be built.
     */
    async redeploySite({ siteId, branch, }) {
        return this.wretch
            .url(`/sites/${siteId}/builds`)
            .json({ branch })
            .post()
            .json();
    }
    /**
     * getSiteBuild retrieves a site build by ID.
     *
     * Returns `null` when no build is found for the given ID.
     */
    async getSiteBuild(buildId) {
        const { data, error } = await this.client["/api/v1/builds/{build_id}"].GET({
            params: { path: { build_id: buildId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to retrieve build", { cause: error });
        }
        return data === undefined ? null : camelize(data);
    }
    /**
     * Deletes all environment variables specified in the `variables` array for a site when passed a
     * `siteId`. When not passed a `siteId`, operates on the team level.
     */
    async deleteEnvironmentVariables({ accountId, siteId = "", variables, }) {
        if (Object.keys(variables).length === 0) {
            return;
        }
        const variablePromises = variables.map((key) => this.deleteEnvironmentVariable({ accountId, siteId, key }));
        await Promise.all(variablePromises);
    }
    /**
     * Creates or updates all environment variables in the `variables` object for a site when passed a
     * `siteId`. When not passed a `siteId`, operates on the team level.
     */
    async createOrUpdateVariables({ accountId, siteId = "", variables, isSecret = false, scopes, }) {
        if (Object.keys(variables).length === 0) {
            return;
        }
        const variablePromises = Object.entries(variables).map(([key, value]) => this.createOrUpdateVariable({
            accountId,
            siteId,
            key,
            value,
            isSecret,
            scopes,
        }));
        await Promise.all(variablePromises);
    }
    /**
     * Creates or updates a single environment variable for a site when passed a `siteId`. When not
     * passed a `siteId`, operates on the team level.
     */
    async createOrUpdateVariable({ accountId, siteId = "", key, value, isSecret = false, scopes, }) {
        let envVarValues = [];
        if (typeof value === "string") {
            envVarValues = [{ value, context: "all" }];
        }
        else if (typeof value === "object") {
            envVarValues = [
                {
                    value: value.dev,
                    context: "dev",
                },
                {
                    value: value.deployPreview,
                    context: "deploy-preview",
                },
                {
                    value: value.production,
                    context: "production",
                },
                {
                    value: value.branchDeploys,
                    context: "branch-deploy",
                },
                ...Object.entries(value.branch ?? {}).map(([branch, value]) => ({
                    value,
                    context: "branch",
                    context_parameter: branch,
                })),
            ];
        }
        const environmentVariables = await this.getEnvironmentVariables({
            accountId,
            siteId,
        });
        const existingVariable = environmentVariables.find((env) => env.key === key);
        if (existingVariable) {
            await this.updateEnvironmentVariable({
                accountId,
                siteId,
                key,
                values: envVarValues,
                isSecret,
                scopes,
            });
        }
        else {
            await this.createEnvironmentVariable({
                accountId,
                siteId,
                key,
                values: envVarValues,
                isSecret,
                scopes,
            });
        }
    }
    /**
     * Gets all environment variables for a site when passed a `siteId`. When not passed a `siteId`,
     * operates on the team level.
     */
    async getEnvironmentVariables({ accountId, siteId = "", }) {
        return this.wretch
            .url(`/accounts/${accountId}/env?site_id=${siteId}`)
            .get()
            .json();
    }
    /**
     * Creates a new environment variable for a site.
     */
    async createEnvironmentVariable({ accountId, siteId = "", key, values, isSecret = false, scopes, }) {
        return await this.wretch
            .url(`/accounts/${accountId}/env?site_id=${siteId}`)
            .json([{ key, values, is_secret: isSecret, scopes }])
            .post()
            .json();
    }
    /**
     * Updates an existing environment variable for a site when passed a `siteId`. When not passed a
     * `siteId`, operates on the team level.
     */
    async updateEnvironmentVariable({ accountId, siteId = "", key, values, isSecret = false, scopes, }) {
        return await this.wretch
            .url(`/accounts/${accountId}/env/${key}?site_id=${siteId}`)
            .headers({
            Authorization: `Bearer ${this.apiKey}`,
            "Content-Type": "application/json",
        })
            .json({ key, values, is_secret: isSecret, scopes })
            .put()
            .json();
    }
    /**
     * Creates or updates an environment variable for a site when passed a `siteId`. When not passed a
     * `siteId`, operates on the team level.
     */
    async patchEnvironmentVariable({ accountId, siteId = "", key, context, value, contextParameter, }) {
        return this.wretch
            .url(`/accounts/${accountId}/env/${key}?site_id=${siteId}`)
            .json({
            context,
            value,
            context_parameter: contextParameter,
        })
            .patch()
            .json();
    }
    /**
     * Deletes an environment variable for a site when passed a `siteId`. When not passed a `siteId`,
     * operates on the team level.
     */
    async deleteEnvironmentVariable({ accountId, siteId = "", key, }) {
        return await this.wretch
            .url(`/accounts/${accountId}/env/${key}?site_id=${siteId}`)
            .delete()
            .res();
    }
    /**
     * Gets a site by ID and returns site information.
     */
    async getSite(siteId) {
        return this.wretch.url(`/sites/${siteId}`).get().json();
    }
    /**
     * Gets all sites for an account.
     */
    async getSites() {
        return this.wretch.url(`/sites`).get().json();
    }
    /**
     * Updates a site with the given changes.
     */
    async updateSite(siteId, changes = {}) {
        return this.wretch
            .url(`/sites/${siteId}`)
            .json(changes)
            .patch()
            .json();
    }
    /**
     * purgeCache purges cached content from Netlify's CDN. Supports purging by Cache-Tag.
     */
    async purgeCache(siteId, cacheTags) {
        // XXX(ndhoule): This API method is not documented in our OpenAPI schema, so use raw fetch here.
        const url = new URL(this.baseURL);
        url.pathname = `${url.pathname}/purge`;
        const res = await fetch(url, {
            method: "POST",
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
                "Api-Version": "2",
                Accept: "application/json",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                site_id: siteId,
                cache_tags: cacheTags,
            }),
        });
        switch (res.status) {
            case 202:
                return;
            case 400:
                throw new Error("Invalid parameters");
            case 404:
                throw new Error("Site not found");
            default:
                throw new Error("Internal server error");
        }
    }
    /**
     * Creates a new build hook for a site.
     */
    async createSiteBuildHook(siteId, input) {
        const { data, error } = await this.client["/api/v1/sites/{site_id}/build_hooks"].POST({
            params: { path: { site_id: siteId } },
            body: input,
        });
        if (error !== undefined) {
            throw new Error("Failed to create build hook", { cause: error });
        }
        if (data === undefined) {
            throw new Error("Failed with unknown error");
        }
        return camelize(data);
    }
    /**
     * Deletes a build hook by site ID and build hook ID.
     */
    async deleteSiteBuildHook(siteId, buildHookId) {
        const { error } = await this.client["/api/v1/sites/{site_id}/build_hooks/{id}"].DELETE({
            params: { path: { site_id: siteId, id: buildHookId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to delete build hook", { cause: error });
        }
    }
    /**
     * Retrieves a build hook by site ID and build hook ID.
     */
    async getSiteBuildHook(siteId, buildHookId) {
        const { data, error, response } = await this.client["/api/v1/sites/{site_id}/build_hooks/{id}"].GET({
            params: { path: { site_id: siteId, id: buildHookId } },
        });
        if (error !== undefined) {
            if (response.status === 404) {
                return null;
            }
            throw new Error("Failed to retrieve build hook", { cause: error });
        }
        return data === undefined ? null : camelize(data);
    }
    /**
     * Lists all build hooks for a site.
     */
    async listSiteBuildHooks(siteId) {
        const { data, error } = await this.client["/api/v1/sites/{site_id}/build_hooks"].GET({
            params: { path: { site_id: siteId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to retrieve build hooks for site", {
                cause: error,
            });
        }
        return data === undefined ? [] : camelize(data);
    }
    /**
     * Updates a build hook by site ID and build hook ID.
     */
    async updateSiteBuildHook(siteId, buildHookId, input) {
        const { error } = await this.client["/api/v1/sites/{site_id}/build_hooks/{id}"].PUT({
            params: { path: { site_id: siteId, id: buildHookId } },
            body: snakeize(input),
        });
        if (error !== undefined) {
            throw new Error("Failed to update build hook", { cause: error });
        }
        const data = await this.getSiteBuildHook(siteId, buildHookId);
        if (data === null) {
            throw new Error("Failed to update build hook");
        }
        return data;
    }
    /**
     * Creates a new build hook for a site.
     *
     * @deprecated Replaced by createSiteBuildHook.
     */
    async createBuildHook(siteId, buildHook) {
        return this.wretch
            .url(`/sites/${siteId}/build_hooks`)
            .json(buildHook)
            .post()
            .json();
    }
    /**
     * Deletes a build hook for a site.
     *
     * @deprecated Replaced by deleteSiteBuildHook.
     */
    async deleteBuildHook(siteId, buildHookId) {
        return this.wretch
            .url(`/sites/${siteId}/build_hooks/${buildHookId}`)
            .delete()
            .res();
    }
    /**
     * Creates a webhook for the given site.
     */
    async createHookBySiteId(siteId, input) {
        const { data, error } = await this.client["/api/v1/hooks"].POST({
            body: snakeize({ siteId, ...input }),
        });
        if (error !== undefined) {
            throw new Error("Failed to create webhook", { cause: error });
        }
        if (data === undefined) {
            throw new Error("Failed with unknown error");
        }
        return camelize(data);
    }
    /**
     * Deletes the given webhook.
     */
    async deleteHook(hookId) {
        const { error } = await this.client["/api/v1/hooks/{hook_id}"].DELETE({
            params: { path: { hook_id: hookId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to delete webhook", { cause: error });
        }
    }
    /**
     * Retrieves a webhook by ID. Returns null if the webhook does not exist.
     */
    async getHook(hookId) {
        const { data, error, response } = await this.client["/api/v1/hooks/{hook_id}"].GET({
            params: { path: { hook_id: hookId } },
        });
        if (error !== undefined) {
            if (response.status === 404) {
                return null;
            }
            throw new Error("Failed to retrieve webhook", { cause: error });
        }
        return data === undefined ? null : camelize(data);
    }
    /**
     * Retrieves a list of webhooks for the given site.
     */
    async listHooksBySiteId(siteId) {
        const { data, error } = await this.client["/api/v1/hooks"].GET({
            params: { query: { site_id: siteId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to retrieve webhooks for site", { cause: error });
        }
        return data === undefined ? [] : camelize(data);
    }
    /**
     * Updates a webhook by ID. Returns the updated webhook.
     */
    async updateHook(hookId, input) {
        const { data, error } = await this.client["/api/v1/hooks/{hook_id}"].PUT({
            params: { path: { hook_id: hookId } },
            body: snakeize(input),
        });
        if (error !== undefined) {
            throw new Error("Failed to update webhook", { cause: error });
        }
        if (data === undefined) {
            throw new Error("Failed with unknown error");
        }
        return camelize(data);
    }
    /**
     * @deprecated Replaced by createHookBySiteId.
     */
    async createHook(CreateHookRequest) {
        return this.wretch
            .url(`/hooks`)
            .json(CreateHookRequest)
            .post()
            .json();
    }
    /**
     * Gets an account by ID and returns account information.
     */
    async getAccount(accountId) {
        return this.wretch.url(`/accounts/${accountId}`).get().json();
    }
    /**
     * Cancels an in-progress deployment.
     */
    async cancelSiteDeploy(deployId) {
        const { data, error } = await this.client["/api/v1/deploys/{deploy_id}/cancel"].POST({
            params: { path: { deploy_id: deployId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to cancel deployment", { cause: error });
        }
        if (data === undefined) {
            throw new Error("Failed to cancel deployment with unknown error");
        }
        return camelize(data);
    }
    /**
     * Creates a new deployment for a site.
     */
    async createSiteDeploy(siteId, input = {}) {
        const { data, error } = await this.client["/api/v1/sites/{site_id}/deploys"].POST({
            params: { path: { site_id: siteId } },
            body: snakeize(input),
        });
        if (error !== undefined) {
            throw new Error("Failed to create deployment", { cause: error });
        }
        if (data === undefined) {
            throw new Error("Failed to create deployment with unknown error");
        }
        return camelize(data);
    }
    /**
     * Deletes a deployment.
     */
    async deleteDeploy(deployId) {
        const { error } = await this.client["/api/v1/deploys/{deploy_id}"].DELETE({
            params: { path: { deploy_id: deployId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to delete deployment", { cause: error });
        }
    }
    /**
     * Retrieves a deployment.
     */
    async getDeploy(deployId) {
        const { data, error } = await this.client["/api/v1/deploys/{deploy_id}"].GET({
            params: { path: { deploy_id: deployId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to get deployment", { cause: error });
        }
        return data === undefined ? null : camelize(data);
    }
    /**
     * Lists deployments for a site.
     */
    async listSiteDeploys(siteId) {
        const { data, error } = await this.client["/api/v1/sites/{site_id}/deploys"].GET({
            params: { path: { site_id: siteId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to list deployments", { cause: error });
        }
        return data === undefined ? [] : camelize(data);
    }
    /**
     * Locks an existing deployment.
     */
    async lockDeploy(deployId) {
        const { error } = await this.client["/api/v1/deploys/{deploy_id}/lock"].POST({
            params: { path: { deploy_id: deployId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to lock deployment", { cause: error });
        }
    }
    /**
     * Restores a site to the specified deployment.
     */
    async restoreSiteDeploy(siteId, deployId) {
        const { data, error } = await this.client["/api/v1/sites/{site_id}/deploys/{deploy_id}/restore"].POST({
            params: { path: { deploy_id: deployId, site_id: siteId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to restore deployment", { cause: error });
        }
        if (data === undefined) {
            throw new Error("Failed to restore deployment with unknown error");
        }
        return camelize(data);
    }
    /**
     * Initiates a deployment rollback for the site, restoring the site to its previous deployment.
     */
    async rollbackSiteDeploy(siteId) {
        const { error } = await this.client["/api/v1/sites/{site_id}/rollback"].PUT({ params: { path: { site_id: siteId } } });
        if (error !== undefined) {
            throw new Error("Failed to roll back deployment", { cause: error });
        }
    }
    /**
     * Unlocks a locked deployment.
     */
    async unlockDeploy(deployId) {
        const { error } = await this.client["/api/v1/deploys/{deploy_id}/unlock"].POST({
            params: { path: { deploy_id: deployId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to unlock deployment", { cause: error });
        }
    }
    /**
     * Deletes a form.
     */
    async deleteSiteForm(siteId, formId) {
        const { error } = await this.client["/api/v1/sites/{site_id}/forms/{form_id}"].DELETE({
            params: { path: { site_id: siteId, form_id: formId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to delete form", { cause: error });
        }
    }
    /**
     * Gets a form.
     */
    async getSiteForm(siteId, formId) {
        const { data, error } = await this.client["/api/v1/sites/{site_id}/forms/{form_id}"].GET({
            params: { path: { site_id: siteId, form_id: formId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to delete form", { cause: error });
        }
        return data === undefined ? null : camelize(data);
    }
    /**
     * Lists forms for a site.
     */
    async listSiteForms(siteId) {
        const { data, error } = await this.client["/api/v1/sites/{site_id}/forms"].GET({
            params: { path: { site_id: siteId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to list forms", { cause: error });
        }
        return data === undefined ? [] : camelize(data);
    }
    /**
     * Creates a log drain for a site.
     */
    async createSiteLogDrain(siteId, input) {
        const { data, error } = await this._client.POST(
        // @ts-expect-error The public OpenAPI schema does not yet include this endpoint
        "/api/v1/sites/{site_id}/log_drains", {
            params: { path: { site_id: siteId } },
            body: snakeize(input),
        });
        if (error !== undefined) {
            throw new Error("Failed to create log drain", { cause: error });
        }
        if (data === undefined) {
            throw new Error("Failed with unknown error");
        }
        return camelize(data);
    }
    /**
     * Deletes a log drain for a site.
     */
    async deleteSiteLogDrain(siteId, logDrainId) {
        const { error } = await this._client.DELETE(
        // @ts-expect-error The public OpenAPI schema does not yet include this endpoint
        "/api/v1/sites/{site_id}/log_drains/{id}", {
            params: { path: { site_id: siteId, id: logDrainId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to delete log drain", { cause: error });
        }
    }
    /**
     * Gets a log drain for a site.
     */
    async getSiteLogDrain(siteId, logDrainId) {
        const { data, error } = await this._client.GET(
        // @ts-expect-error The public OpenAPI schema does not yet include this endpoint
        "/api/v1/sites/{site_id}/log_drains/{id}", {
            params: { path: { site_id: siteId, id: logDrainId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to get log drain", { cause: error });
        }
        return data === undefined ? null : camelize(data);
    }
    /**
     * Lists a site's log drains.
     */
    async listSiteLogDrains(siteId) {
        const { data, error } = await this._client.GET(
        // @ts-expect-error The public OpenAPI schema does not yet include this endpoint
        "/api/v1/sites/{site_id}/log_drains", {
            params: { path: { site_id: siteId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to get log drains", { cause: error });
        }
        return data === undefined ? [] : camelize(data);
    }
    /**
     * Updates a log drain for a site.
     */
    async updateSiteLogDrain(siteId, logDrainId, input) {
        const { data, error } = await this._client.PUT(
        // @ts-expect-error The public OpenAPI schema does not yet include this endpoint
        "/api/v1/sites/{site_id}/log_drains/{id}", {
            params: { path: { site_id: siteId, id: logDrainId } },
            body: snakeize(input),
        });
        if (error !== undefined) {
            throw new Error("Failed to update log drain", { cause: error });
        }
        if (data === undefined) {
            throw new Error("Failed with unknown error");
        }
        return camelize(data);
    }
    /**
     * Returns a configured @netlify/blobs#Blobs client for the given site and blob store name.
     *
     * @see The {@link <a href="https://www.npmjs.com/package/@netlify/blobs" target="_blank" rel="noopener noreferrer">@netlify/blobs</a>} package
     */
    getBlobStore(siteId, storeName) {
        // Contrary to its documentation, the blobs client will completely ignore most user-defined
        // configuration if NETLIFY_BLOBS_CONTEXT is populated, frequently preferring configuration from
        // the environment instead. This means the blob client only works as the docs suggest in a
        // non-Netlify environment--which is a bummer, because we'll always be running this code in a
        // Netlify environment.
        //
        // Fixing the blob store client is invasive and may be a breaking change, so work around this by
        // temporarily hiding the environment configuration. (`getStore` executes synchronously, so this
        // is gross, but safe.)
        const previousNetlifyBlobsContext = process.env["NETLIFY_BLOBS_CONTEXT"];
        process.env["NETLIFY_BLOBS_CONTEXT"] = "";
        const store = blobs.getStore({
            apiURL: this.baseURL.replace(/\/api\/v1\/?$/, ""),
            consistency: "strong",
            name: storeName,
            siteID: siteId,
            token: this.apiKey,
        });
        process.env["NETLIFY_BLOBS_CONTEXT"] = previousNetlifyBlobsContext;
        return store;
    }
    /**
     * Lists a site's DNS records
     */
    async getDnsForSite(siteId) {
        const { data, error } = await this._client.GET("/api/v1/sites/{site_id}/dns", {
            params: { path: { site_id: siteId } },
        });
        if (error !== undefined) {
            throw new Error("Failed to get DNS for site", { cause: error });
        }
        return data === undefined ? [] : camelize(data);
    }
}
//# sourceMappingURL=netlify_api_client.js.map