import { type MessageChannel } from "../message_channel/main.js";
import { type UIExtensionHostEvent, type UIExtensionHostInitializeEvent, type UIExtensionSurfaceConnectProviderEvent, type UIExtensionSurfaceDisconnectProviderEvent, type UIExtensionSurfaceEvent } from "../message_schema/main.js";
import { Surfaces } from "../surfaces.js";
export interface NetlifySDK {
    listen: () => void;
    onChange: (callback: () => void) => () => void;
    beginProviderAuthFlow: (data?: UIExtensionSurfaceConnectProviderEvent["data"]) => Promise<void>;
    disconnectProviderAuth: (data?: UIExtensionSurfaceDisconnectProviderEvent["data"]) => Promise<void>;
    context: {
        auth: {
            netlifyToken: string | null;
            providerToken: string | null;
            providerTokens: {
                externalId: string;
                token: string;
                connectionId: string;
            }[];
        };
        user: {
            id: string | null;
        };
        configurationId: string | null;
        dataLayerId: string | null;
        projectId: string | null;
        siteId: string | null;
        /**
         * `teamId` is an alias for `accountId`
         */
        teamId: string | null;
        /**
         * `accountId` is an alias for `teamId`
         */
        accountId: string | null;
        theme: "light" | "dark";
        visualEditor: {
            webhookBaseURL: string | null;
            projectId: string | null;
            notifyVisualEditor: boolean | null;
        };
        deployId: string | null;
    };
    extension: {
        id: string;
        name: string;
        slug: string;
    };
    requestDimensions: (dimensions: {
        height: number;
        width: number;
    }) => void;
    surface: {
        is: (value: string) => boolean;
        name: Surfaces | null;
    };
    /**
     * `requestTerminate` allows a surface that has finished interacting with a user communicate to
     * the Netlify UI that it is ready to surrender control back to the Netlify UI. Depending on the
     * surface, the Netlify UI will optionally respect this signal.
     *
     * For example: The Netlify UI expects the Create and Visual Editor surfaces to surrender
     * control back to the Netlify UI when they have successfully collected and persisted data from
     * the user.
     */
    requestTermination: () => void;
}
/**
 * @internal
 */
export declare const createSDK: (messageChannel: MessageChannel<UIExtensionHostEvent, UIExtensionSurfaceEvent>, data: UIExtensionHostInitializeEvent["data"]) => NetlifySDK;
/**
 * @internal
 */
export type InitializeSDKOptions = {
    /**
     * A messaging channel used to communicate between the SDK consumer and the host frame.
     */
    messageChannel: MessageChannel<UIExtensionHostEvent, UIExtensionSurfaceEvent>;
};
/**
 * @internal
 */
export declare const initializeSDK: ({ messageChannel, }: InitializeSDKOptions) => Promise<NetlifySDK>;
//# sourceMappingURL=sdk.d.ts.map