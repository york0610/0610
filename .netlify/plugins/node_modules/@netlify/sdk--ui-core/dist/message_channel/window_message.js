var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// TODO(ndhoule): Some of the logic in this (abort signal combining/following, basic message
// parsing, etc.) should be abstracted out into another interface
import { subscribe } from "event-iterator/lib/dom.js";
import { abortSignalAny } from "../utils/abort_signal_any.js";
import { promiseWithResolvers } from "../utils/promise_with_resolvers.js";
import { BaseMessageSchema } from "./schemas.js";
import {} from "./types.js";
/**
 * `createWindowMessageWriter` creates a `MessageWriter` that uses the `postMessage` browser API to
 * write messages.
 *
 * By default, it sends messages on the global `window`  messages target the current origin. You
 * can override either by specifying `targetWindow` and/or `targetOrigin` (respectively).
 */
export const createWindowMessageWriter = ({ signal, targetOrigin = window.location.origin, targetWindow = window, } = {}) => {
    return {
        send: (_a) => __awaiter(void 0, [_a], void 0, function* ({ data, type }) {
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                return;
            }
            targetWindow.postMessage({ data, type }, targetOrigin);
            return Promise.resolve(undefined);
        }),
    };
};
/**
 * `createWindowMessageReader` creates a `MessageReader` that listens for window `message` events.
 *
 * By default, it listens for messages on the global `window`  and only permits messages that
 * originate from the current origin (`window.location.origin`). You can override either by
 * specifying `targetWindow` and `whitelistedOrigins` (respectively).
 */
// TODO(ndhoule): There's not really much here that's specific to window, abstract this into an
// EventTarget reader and compose a window reader out of it. This would make mocking the reader in
// tests and Storybook much easier
export const createWindowMessageReader = ({ isOriginPermitted = (origin) => origin === window.location.origin, signal: readerSignal, targetWindow = window, } = {}) => {
    return {
        subscribe: ({ signal: subscriptionSignal } = {}) => {
            const signal = abortSignalAny([readerSignal, subscriptionSignal].filter((signal) => signal !== undefined));
            if (signal.aborted) {
                throw new Error("Reader is closed, cannot subscribe to a closed reader");
            }
            return {
                [Symbol.asyncIterator]() {
                    // TODO(ndhoule): Replace this with a modified vendored version. It's not very much code
                    // (I'm just using the package to get started) and it works--however:
                    //
                    // - This implementation doesn't natively follow AbortSignals, which we need in order to
                    //   end the infinite loop in the iterator's `next` method. The event listener below works
                    //   but isn't ideal/assumes some implementation details, like the presence of a return
                    //   method on the iterator
                    // - It does high/low watermarking, which we don't need
                    // - The interface is garbage. What's this call nonsense? why not just take the target as
                    //   the first argument...?
                    const subscription = subscribe.call(targetWindow, "message", undefined, {
                        highWaterMark: undefined,
                        lowWaterMark: undefined,
                    });
                    const subscriptionIterator = subscription[Symbol.asyncIterator]();
                    signal.addEventListener("abort", () => {
                        void subscriptionIterator.return({
                            done: true,
                            value: undefined,
                        });
                    }, { once: true });
                    return {
                        next: () => __awaiter(this, void 0, void 0, function* () {
                            while (true) {
                                // FIXME(ndhoule): This _works_, but it's more complicated than it needs to be. The
                                // `return` method on event-iterator doesn't resolve its outstanding pullQueue
                                // promises when the iterator closes, so if we're iterating when the subscription
                                // closes we'll end up waiting forever. The solution here is to fix this bug (or,
                                // accept and use an AbortSignal, which is preferable anyway).
                                const { promise, resolve } = promiseWithResolvers();
                                const onAbort = () => {
                                    resolve(null);
                                };
                                signal.addEventListener("abort", onAbort, { once: true });
                                const result = yield Promise.race([
                                    subscriptionIterator.next(),
                                    promise,
                                ]);
                                signal.removeEventListener("abort", onAbort);
                                if (result === null) {
                                    return { done: true, value: undefined };
                                }
                                if (result.done) {
                                    return { done: true, value: undefined };
                                }
                                const event = result.value;
                                if (!isOriginPermitted(event.origin)) {
                                    // Skip invalid message and wait for the next
                                    continue;
                                }
                                const parseResult = BaseMessageSchema.safeParse(event.data);
                                if (!parseResult.success) {
                                    // Skip invalid message and wait for the next
                                    continue;
                                }
                                return { done: false, value: parseResult.data };
                            }
                            // This condition should be impossible
                            throw new Error("Terminated message wait loop. This is a bug in the SDK.");
                        }),
                        return: () => __awaiter(this, void 0, void 0, function* () {
                            yield subscriptionIterator.return(undefined);
                            return { done: true, value: undefined };
                        }),
                    };
                },
            };
        },
    };
};
//# sourceMappingURL=window_message.js.map