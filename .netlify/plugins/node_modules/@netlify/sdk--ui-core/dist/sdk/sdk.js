var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import {} from "../message_channel/main.js";
import { createUIExtensionSurfaceConnectProviderEvent, createUIExtensionSurfaceDisconnectProviderEvent, createUIExtensionSurfaceInitializeEvent, createUIExtensionSurfaceRequestTerminationEvent, createUIExtensionSurfaceResizeEvent, UI_EXTENSION_HOST_INITIALIZE_EVENT_TYPE, UI_EXTENSION_HOST_UPDATE_CONTEXT_EVENT_TYPE, } from "../message_schema/main.js";
import { Surfaces } from "../surfaces.js";
/**
 * @internal
 */
export const createSDK = (messageChannel, data) => {
    const eventTarget = new EventTarget();
    const sdk = {
        listen: () => {
            // TODO(ndhoule): Don't leave this promise hanging
            // TODO(ndhoule): Catch and handle errors; should wrap the loop contents in a try/catch so the
            // message handler doesn't disconnect on error
            //
            // Begin listening for non-initialization messages from the host in the background.
            void (() => __awaiter(void 0, void 0, void 0, function* () {
                var _a, e_1, _b, _c;
                try {
                    for (var _d = true, _e = __asyncValues(messageChannel.subscribe()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                        _c = _f.value;
                        _d = false;
                        const { data, type } = _c;
                        switch (type) {
                            case UI_EXTENSION_HOST_UPDATE_CONTEXT_EVENT_TYPE: {
                                sdk.context = data.context;
                                eventTarget.dispatchEvent(new CustomEvent("change", {}));
                                break;
                            }
                            default:
                            // Ignore unknown message types
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }))();
        },
        // TODO(ndhoule): We should refactor this into a slightly more generic eventing system;
        // I can imagine we'll want to observe for changes on routing state, context changes,
        // etc.
        onChange: (baseCallback) => {
            const callback = () => {
                baseCallback();
            };
            // FIXME(ndhoule): We probably should not error on missing event target, but I suspect
            // I'm going to refactor this very soon, so I'm leaving this hack in for now
            eventTarget.addEventListener("change", callback);
            return () => {
                eventTarget.removeEventListener("change", callback);
            };
        },
        // TODO(ndhoule): Convert to async interface
        beginProviderAuthFlow: (data) => __awaiter(void 0, void 0, void 0, function* () {
            void messageChannel.send(createUIExtensionSurfaceConnectProviderEvent(data));
            return Promise.resolve();
        }),
        // TODO(ndhoule): Convert to async interface
        disconnectProviderAuth: (data) => __awaiter(void 0, void 0, void 0, function* () {
            void messageChannel.send(createUIExtensionSurfaceDisconnectProviderEvent(data));
            return Promise.resolve();
        }),
        context: data.context,
        extension: data.extension,
        surface: {
            is: (value) => { var _a; return value === ((_a = sdk.surface.name) === null || _a === void 0 ? void 0 : _a.toString()); },
            name: data.surface.name,
        },
        // TODO(ndhoule): Convert to async interface
        requestDimensions: (dimensions) => {
            void messageChannel.send(createUIExtensionSurfaceResizeEvent({ dimensions }));
        },
        /**
         * `requestTermination` allows a surface that has finished interacting with a user communicate
         * to the Netlify UI that it is ready to surrender control back to the Netlify UI. Depending on
         * the surface, the Netlify UI will optionally respect this signal.
         *
         * For example: The Netlify UI expects the Create and Visual Editor surfaces to surrender
         * control back to the Netlify UI when they have successfully collected and persisted data from
         * the user.
         *
         * If you find yourself reaching for this, it's generally a good sign that maybe we should
         * redesign part of the Netlify UI to more fluidly integrate the Extension UI.
         */
        requestTermination: () => {
            void messageChannel.send(createUIExtensionSurfaceRequestTerminationEvent());
        },
    };
    return sdk;
};
/**
 * @internal
 */
export const initializeSDK = (_a) => __awaiter(void 0, [_a], void 0, function* ({ messageChannel, }) {
    // Send a startup signal to the host frame and wait for an acknowledgement.
    const [sdk] = yield Promise.all([
        // Wait for the acknowledgement message, which contains information necessary to start the app.
        // The acknowledgement will contain information necessary to start the app, like: information
        // about the extension like ID and slug; and session context like provider- and Netlify-specific
        // authentication tokens, etc.
        (() => __awaiter(void 0, void 0, void 0, function* () {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(messageChannel.subscribe()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const { data, type } = _c;
                    if (type === UI_EXTENSION_HOST_INITIALIZE_EVENT_TYPE) {
                        return createSDK(messageChannel, data);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return null;
        }))(),
        // Send an initialization event to the host frame
        messageChannel.send(createUIExtensionSurfaceInitializeEvent()),
    ]);
    // This is unlikely, but it can happen if the messageChannel stops listening (e.g. its signal is
    // cancelled) before we receive an initialization message from the host.
    if (sdk === null) {
        throw new Error("Failed to initialize SDK.");
    }
    sdk.listen();
    return sdk;
});
//# sourceMappingURL=sdk.js.map