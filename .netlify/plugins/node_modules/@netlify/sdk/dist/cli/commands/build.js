import events from "node:events";
import { existsSync } from "node:fs";
import { isBuiltin } from "node:module";
import fs from "node:fs/promises";
import path from "node:path";
import { build as esbuild, context, } from "esbuild";
import { copy } from "esbuild-plugin-copy";
import { buildDetailsFile, buildExtensionUI, generateBuildEventHandler, validateDetailsFile, copySiteAssets, } from "../index.js";
import { getExtensionBuildInfo, getExtensionModule, getDepNames, } from "../util.js";
import { resolveExtensionConfiguration, } from "../../extension_configuration/main.js";
import { ntliLog, printResetHeader } from "../../utils.js";
import { getPackageVersion } from "../../extension/package-version.js";
export const getDefaultEsbuildConfig = (config) => {
    if (config.use_cjs_shims) {
        return { inject: [path.join(__dirname, `../cjs-shim.js`)] };
    }
    return {};
};
const cleanOutputDirectory = async (_ctx, outDir) => {
    // remove dist folders
    await fs.rm(outDir, { recursive: true, force: true });
};
const buildExtensionCore = async ({ signal }, { config, entrypoint, extensionPackageJson, mode, outfile, skipInitialBuild = false, esbuildSeenModules, }) => {
    if (signal.aborted) {
        return;
    }
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [entrypoint],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile,
        external: getDepNames(extensionPackageJson),
        sourcemap: "linked",
        plugins: [
            copy({
                assets: {
                    from: ["./README.md"],
                    to: ["./README.md"],
                    watch: mode === "watch"
                        ? {
                            // The copy plugin's default behavior is to continue polling, even after the event
                            // loop is otherwise empty. We don't want it to hold open the process if it's the
                            // last thing in the event loop, so we need to specify persistent: false.
                            // https://github.com/paulmillr/chokidar?tab=readme-ov-file#persistence
                            persistent: false,
                        }
                        : false,
                },
            }),
        ],
    };
    if (mode === "watch") {
        const buildContext = await context(esbuildOptions);
        // The signal may have been cancelled while we were starting esbuild...
        if (signal.aborted) {
            // ...in which case, we should stop any in-progress builds and stop the watcher
            await buildContext.cancel();
            await buildContext.dispose();
            return;
        }
        if (!skipInitialBuild) {
            await buildContext.rebuild();
        }
        printResetHeader();
        await buildContext.watch();
        // esbuild's .watch() method watches in the background.
        // The canonical way to stop the watcher is to abort the signal
        await events.once(signal, "abort");
        await buildContext.cancel();
        await buildContext.dispose();
    }
    else {
        // only check for seen imported node modules for prod builds, not during local dev
        esbuildOptions.plugins = [
            ...(esbuildOptions.plugins ?? []),
            esbuildSeenModules.plugin,
        ];
        await esbuild(esbuildOptions);
    }
};
const buildExtensionManifest = async (_ctx, { config, extension, siteOutDir, }) => {
    const version = getPackageVersion();
    const hasBuildEventHandler = Object.keys(extension.getBuildEventHandlersToRun()).length > 0;
    let uiSurfaces = [];
    let hasExtensionUI = false;
    if (config.ui?.surfaces != undefined && config.ui.surfaces.length > 0) {
        // TODO(ndhoule): This is a fairly weak check. We should check to be sure the user has actually
        // emitted artifacts to the build directory defined at `netlify.toml#build.publish`. (We should
        // actually use @netlify/config)
        hasExtensionUI = true;
        uiSurfaces = [...config.ui.surfaces];
    }
    // TODO(ndhoule): When in `ntli dev` mode, we should write the manifest in watch mode. To do this
    // reliably, we'll need to watch the `extension.yml` file for changes.
    const manifest = {
        sdkVersion: version,
        hasBuildEventHandler,
        hasIntegrationUI: hasExtensionUI,
        uiSurfaces,
    };
    if (!existsSync(siteOutDir)) {
        await fs.mkdir(siteOutDir, { recursive: true });
    }
    await fs.writeFile(path.resolve(siteOutDir, "manifest.json"), JSON.stringify(manifest, null, 2));
};
const __dirname = new URL(".", import.meta.url).pathname;
export const build = async ({ signal }, opts) => {
    const isPreview = !!opts.previewUrl;
    const config = await resolveExtensionConfiguration({ cwd: opts.cwd });
    const { outDir, builtPath, sourceFilePath, extensionPackageJson } = await getExtensionBuildInfo({
        cwd: opts.cwd,
        outDirOveride: opts.outDir,
    });
    const siteOutDir = path.resolve(outDir, "site/static");
    const detailsMdEntrypoint = path.resolve(opts.cwd, "details.md");
    const detailsMdOutfile = path.join(siteOutDir, "details.md");
    await cleanOutputDirectory({ signal }, outDir);
    // Before we do (almost) anything, build the extension core so we can get some information about
    // which features it supports.
    const esbuildSeenModules = esbuildPluginSeenNodeModules({
        markAsExternal: false,
    });
    await buildExtensionCore({ signal }, {
        config,
        entrypoint: sourceFilePath,
        extensionPackageJson,
        mode: "build",
        outfile: builtPath,
        esbuildSeenModules,
    });
    const extension = await getExtensionModule(builtPath, opts.cwd);
    if (!extension) {
        return false;
    }
    if (opts.buildtime) {
        ntliLog("Generating build event handlers...");
        await generateBuildEventHandler(extension, { ...config, slug: isPreview ? "netlify-preview" : config.slug }, {
            cwd: opts.cwd,
            outDir,
        });
    }
    await buildExtensionManifest({ signal }, { config, extension, siteOutDir });
    let buildExtensionUIPromise = null;
    if (opts.site) {
        if (config.ui === undefined) {
            ntliLog("No Extension UI configuration found. Skipping UI build...");
        }
        else {
            ntliLog("Copying `details.md` to build...");
            const detailsFileValidationResult = await validateDetailsFile({
                src: detailsMdEntrypoint,
            });
            if (!detailsFileValidationResult.success) {
                throw detailsFileValidationResult.error;
            }
            await buildDetailsFile({
                src: detailsMdEntrypoint,
                dest: detailsMdOutfile,
            });
            ntliLog("Copied `details.md` to build.");
            // TODO(ndhoule): This exists to allow users to reference images, etc. in their details.md file.
            // However, I think we'll need to revisit it for a few reasons:
            //
            // - The `ntli` build process should not write to the `${outputDir}/site/static/ui` directory;
            //   that directory must be completely controlled by the UI build tool, which often chooses to
            //   truncate the output directory before building. (E.g. this is Vite's default behavior.)
            // - The UI build process can also place assets in the `ui` directory, and might create a
            //   `ui/assets` directory. (E.g. this is Vite's default behavior.)
            // - It's odd that we output the manifest to `${outputDir}/site/static` and this to `[...]/ui`?
            copySiteAssets({ cwd: opts.cwd, outDir });
            ntliLog(`Building Extension UI${opts.mode === "dev" ? " in watch mode" : ""}...`);
            buildExtensionUIPromise = buildExtensionUI({
                signal,
                stderr: process.stderr,
                stdout: process.stdout,
            }, {
                command: {
                    dev: config.ui?.dev?.command,
                },
                cwd: opts.cwd,
                outdir: outDir,
                mode: opts.mode,
                meta: {
                    name: config.name ?? "",
                    slug: config.slug,
                },
                open: opts.open,
                slug: opts.slug,
            });
            if (opts.mode === "build") {
                // If we're in build mode, wait for the UI build to finish before continuing.
                await buildExtensionUIPromise;
            }
        }
    }
    if (opts.mode === "dev") {
        await Promise.all([
            buildExtensionUIPromise,
            buildExtensionCore({ signal }, {
                config,
                entrypoint: sourceFilePath,
                extensionPackageJson,
                mode: "watch",
                outfile: builtPath,
                skipInitialBuild: true, // We just built the extension, so we can just watch for changes now
                esbuildSeenModules,
            }),
        ]);
    }
    if (opts.mode === "build") {
        ntliLog("Build complete!");
    }
};
export const esbuildPluginSeenNodeModules = ({ markAsExternal = false, }) => {
    const moduleImports = new Set();
    return {
        nodeModulesImports: moduleImports,
        plugin: {
            name: "capture-node-modules-imports",
            setup(build) {
                build.onResolve({ filter: /.*/ }, (args) => {
                    // err on the side of including more rather than fewer deps.
                    // if an import isn't relative, add the path as a seen import
                    // we compare moduleImports against the actual package.json
                    // so if some extra imports are added as false positives it doesn't matter
                    const isNodeModuleImport = !args.path.startsWith(`.`) &&
                        !args.path.startsWith(`/`) &&
                        !isBuiltin(args.path);
                    if (isNodeModuleImport) {
                        moduleImports.add(args.path); // Capture the node module import path
                        if (markAsExternal) {
                            return { path: args.path, external: true };
                        }
                    }
                    return {};
                });
                if (process.env.LOG_LEVEL === `DEBUG`) {
                    build.onEnd(() => {
                        console.log("Node module imports seen during bundling:", Array.from(moduleImports));
                    });
                }
            },
        },
    };
};
//# sourceMappingURL=build.js.map