{"version":3,"file":"index.js","sourceRoot":"/","sources":["index.ts"],"names":[],"mappings":"AAAA,OAAO,SAAS,MAAM,kBAAkB,CAAC;AA6BzC,SAAS,IAAI,CAAC,GAAG,EAAE,OAAO,GAAG,KAAK;IAChC,IAAI,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ;QAAE,OAAO,GAAG,CAAC;IAChD,IAAI,GAAG,YAAY,IAAI,IAAI,GAAG,YAAY,MAAM;QAAE,OAAO,GAAG,CAAC;IAC7D,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC;QAAE,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YACzC,IAAI,CAAC,OAAO,EAAE;gBAAE,OAAO,IAAI,CAAC,CAAC,CAAC,CAAA;aAAE;YAChC,IAAI,OAAO,CAAC,KAAK,QAAQ;gBAAE,OAAO,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,CAAA;YAClD,OAAO,CAAC,CAAA;QACV,CAAC,CAAC,CAAA;IAEF,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;QAC1C,MAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;QAC7B,GAAG,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QACjD,OAAO,GAAG,CAAC;IACb,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC;AAED,MAAM,CAAC,OAAO,UAAU,OAAO;AAC7B;;GAEG;AACH,GAAM;AAEN;;GAEG;AACH,OAAW;IAEX,OAAO,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AACvE,CAAC","sourcesContent":["import snakeCase from \"lodash.snakecase\";\n\n/**\n * @see https://newbedev.com/typescript-convert-generic-object-from-snake-to-camel-case\n */\ntype SnakeCase<S extends string> = S extends `${infer T}${infer U}`\n  ? `${T extends Capitalize<T> ? \"_\" : \"\"}${Lowercase<T>}${SnakeCase<U>}`\n  : S;\n\ntype SnakifyObject<T, S = false> = {\n  [K in keyof T as SnakeCase<string & K>]:\n    T[K] extends Date ? T[K] :\n      T[K] extends RegExp ? T[K] :\n        T[K] extends Array<infer U>\n          ? U extends ({} | undefined)\n            ? Array<SnakifyObject<U>>\n            : T[K]\n          : T[K] extends ({} | undefined)\n          ? S extends true\n            ? T[K]\n            : SnakifyObject<T[K]>\n          : T[K];\n};\n\nexport type Snakify<T, S = false> =\n  T extends Array<(infer U)>\n    ? Array<SnakifyObject<U, S>>\n    : SnakifyObject<T, S>;\n\nfunction walk(obj, shallow = false): any {\n  if (!obj || typeof obj !== \"object\") return obj;\n  if (obj instanceof Date || obj instanceof RegExp) return obj;\n  if (Array.isArray(obj)) return obj.map(v => {\n    if (!shallow) { return walk(v) }\n    if (typeof v === 'object') return walk(v, shallow)\n    return v\n  })\n\n  return Object.keys(obj).reduce((res, key) => {\n    const camel = snakeCase(key);\n    res[camel] = shallow ? obj[key] : walk(obj[key]);\n    return res;\n  }, {});\n}\n\nexport default function snakify<T, S extends boolean = false>(\n  /**\n   * Value to be snakified\n   */\n  obj: T,\n\n  /**\n   * If true, only the top level keys of the obj will be camel cased\n   */\n  shallow?: S\n): T extends String ? string : Snakify<T, S> {\n  return typeof obj === \"string\" ? snakeCase(obj) : walk(obj, shallow);\n}"]}