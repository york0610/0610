import path, { dirname, join, resolve } from "node:path";
import fs from "node:fs/promises";
import { fileURLToPath } from "node:url";
import { z } from "zod";
import { NetlifyExtensionClient, NetlifyExtensionBuildClient, } from "../api/index.js";
import { envVarFromSlug } from "../utils.js";
import { defaultOnUninstallHandler, defaultOnDisconnectHandler, defaultOnInstallHandler, } from "./api/handlers.js";
import { EXTENSION_API_URL_PROD, EXTENSION_API_URL_STAGING, } from "../constants/urls.js";
import { createExtensionEndpointFetch } from "../utils/extension_endpoint_fetch.js";
/**
 * A schema of extension-specific configuration. Used to parse extension configuration from an end
 * user's netlify.toml.
 */
const NetlifySDKConfigExtensionSchema = z.array(z.object({
    /**
     * The extension slug. Used to match the configuration to the extension it configures.
     */
    name: z.string(),
    /**
     * An extension-specific configuration object.
     */
    config: z.unknown().optional(),
    /**
     * Configuration used by extension developers to test
     */
    dev: z
        .object({
        /**
         * A path to a local extension directory, or to a packed (tarball) build plugin.
         *
         * When running `netlify build` or `netlify dev` in a site that consumes the extension, the
         * extension's build plugin will be installed and run.
         *
         * When this path is defined and points at a tarball, the tarball is installed. When the
         * path is a directory, attempts to locate a tarball at the default build plugin output path
         * (`<path>/.ntli/site/static/packages/buildhooks.tgz`).
         */
        path: z.string().optional(),
    })
        .optional(),
}));
const NetlifySDKConfigSchema = z
    .object({
    integrations: NetlifySDKConfigExtensionSchema.optional().default(() => []),
})
    .optional()
    .default(() => ({ integrations: [] }));
const ProviderTokensSchema = z.array(z.object({
    token: z.string().min(1).trim(),
    externalId: z.string().min(1).trim(),
    connectionId: z.string().min(1).trim(),
}));
const parseProviderTokens = (headers) => {
    if (!headers) {
        return [];
    }
    try {
        return ProviderTokensSchema.parse(JSON.parse(headers));
    }
    catch (e) {
        console.error("Failed to parse provider tokens header", e);
        return [];
    }
};
export class NetlifyExtension {
    _edgeFunctionsSettings;
    _functionsSettings;
    _slug = "";
    _hostSiteId;
    _buildHooks = {
        onPreBuild: null,
        onBuild: null,
        onPostBuild: null,
        onSuccess: null,
        onError: null,
        onEnd: null,
        onPreDev: null,
        onDev: null,
    };
    _handlers = {
        "on-install": defaultOnInstallHandler,
        "on-uninstall": defaultOnUninstallHandler,
        "on-disconnect": defaultOnDisconnectHandler,
    };
    #parseBuildConfig;
    constructor({ parseBuildConfig, } = {}) {
        if (parseBuildConfig !== undefined) {
            this.#parseBuildConfig = parseBuildConfig;
        }
    }
    get buildSlug() {
        return envVarFromSlug(this._slug);
    }
    /**
     * Used to add a build event handlers to the extension.
     */
    addBuildEventHandler(type, func) {
        this._buildHooks[type] = async (context) => {
            const { netlifyConfig, constants } = context;
            const buildConfig = this.getBuildConfig({ netlifyConfig });
            const { ACCOUNT_ID, SITE_ID } = constants;
            const shouldInjectFunctions = type === "onPreBuild" || type === "onPreDev";
            if (shouldInjectFunctions &&
                this._functionsSettings !== undefined &&
                this._functionsSettings.prefix &&
                this._functionsSettings.path) {
                // context.utils.functions.generate is an API that was introduced in netlify-cli@22.2.2. If
                // the end user is building a site using an older version of the CLI, this API will not be
                // available, and we'll need to fall back to a legacy function injection API.
                if (typeof context.utils.functions.generate === "function") {
                    const generatedFunctions = await this.getGeneratedFunctions({
                        prefix: this._functionsSettings.prefix,
                        shouldInjectFunction: this._functionsSettings.shouldInjectFunction,
                    });
                    for (const generatedFunction of generatedFunctions) {
                        context.utils.functions.generate(generatedFunction.path);
                    }
                }
                else {
                    await this.legacyInjectFunctions({
                        constants,
                        prefix: this._functionsSettings.prefix,
                        shouldInjectFunction: this._functionsSettings.shouldInjectFunction,
                    })();
                }
            }
            if (shouldInjectFunctions &&
                this._edgeFunctionsSettings !== undefined &&
                this._edgeFunctionsSettings.prefix &&
                this._edgeFunctionsSettings.path) {
                await this.injectEdgeFunctions({
                    constants,
                    prefix: this._edgeFunctionsSettings.prefix,
                    shouldInjectFunction: this._edgeFunctionsSettings.shouldInjectFunction,
                })();
            }
            const netlifyBuildbotToken = context.extensionMetadata?.extension_token || "";
            const isStaging = constants?.NETLIFY_API_HOST?.includes(`api-staging.netlify.com`);
            const jigsawUrl = isStaging
                ? EXTENSION_API_URL_STAGING
                : EXTENSION_API_URL_PROD;
            const netlifyApiUrl = isStaging
                ? `${EXTENSION_API_URL_STAGING}/api/v1`
                : `${EXTENSION_API_URL_PROD}/api/v1`;
            const client = new NetlifyExtensionBuildClient(netlifyBuildbotToken, this._slug, {
                jigsawUrl,
                netlifyApiUrl,
                netlifyTokenIssuer: "buildbot",
            });
            const extensionEndpointFetch = createExtensionEndpointFetch({
                extension: { slug: this._slug, id: this._hostSiteId || "" },
                netlifyToken: netlifyBuildbotToken,
                netlifyTokenIssuer: "buildbot",
                siteId: SITE_ID,
                teamId: ACCOUNT_ID,
            });
            return func({
                ...context,
                buildConfig,
                client,
                extensionEndpointFetch,
            });
        };
    }
    /**
     * Used to add an endpoint to the extension.
     */
    addEndpoint(name, handler) {
        this._handlers[name] = handler;
    }
    /**
     * The handler to use for the onInstall endpoint.
     */
    onInstall(handler) {
        this._handlers["on-install"] = async (event, context) => {
            const res = await defaultOnInstallHandler(event, context);
            if (res.statusCode !== 200) {
                return res;
            }
            const { siteId, teamId } = JSON.parse(event.body ?? "{}");
            return handler(event, {
                ...context,
                siteId: siteId ?? null,
                teamId: teamId ?? null,
            });
        };
    }
    /**
     * The handler to use for the onUninstall endpoint.
     */
    onUninstall(handler) {
        this._handlers["on-uninstall"] = async (event, context) => {
            if (event.body === null) {
                return {
                    statusCode: 400,
                    body: JSON.stringify({ message: "Missing body" }),
                };
            }
            const { teamId } = JSON.parse(event.body);
            if (!teamId) {
                return {
                    statusCode: 400,
                    body: JSON.stringify({ message: "Missing teamId" }),
                };
            }
            const integrationHandlerRes = await handler(event, context);
            if (integrationHandlerRes.statusCode !== 200 &&
                integrationHandlerRes.statusCode !== 204) {
                return integrationHandlerRes;
            }
            return await defaultOnUninstallHandler(event, context);
        };
    }
    /**
     * The handler to use for the onDisconnect endpoint.
     */
    onDisconnect(handler) {
        this._handlers["on-disconnect"] = async (event, context) => {
            const integrationHandlerRes = await handler(event, context);
            if (integrationHandlerRes.statusCode !== 200) {
                return integrationHandlerRes;
            }
            return {
                statusCode: 200,
                body: "Disconnected",
            };
        };
    }
    addWebhookHandler(name, handler) {
        const webhookName = name ? `webhook-${name}` : "webhook";
        this._handlers[webhookName] = handler;
    }
    /**
     * Used to inject edge functions into the user's site.
     */
    injectEdgeFunctions({ constants, prefix, shouldInjectFunction, }) {
        return async () => {
            const { INTERNAL_EDGE_FUNCTIONS_SRC } = constants;
            if (!INTERNAL_EDGE_FUNCTIONS_SRC) {
                throw new Error("INTERNAL_EDGE_FUNCTIONS_SRC is not available for this Build Event Handler.");
            }
            // The ef directory will be in the site's base directory if defined, or in the repository root.
            const outDir = join(INTERNAL_EDGE_FUNCTIONS_SRC); //.netlify/edge-functions
            // create the edge functions directory if it doesn't exist
            await fs.mkdir(outDir, { recursive: true });
            const __filename = fileURLToPath(import.meta.url);
            const __dirname = dirname(__filename);
            // Find the edge functions we've copied over into the extension's build folder
            const sourcePath = join(__dirname, "edge-functions");
            try {
                const edgeFunctions = await fs.readdir(sourcePath, {
                    withFileTypes: true,
                });
                const copyPromises = edgeFunctions.map((item) => {
                    // Strip the prefix from the filename to match the user's original function name. Also
                    // strip off the file extension (if any) to that directories containing functions don't
                    // have special treatment vs. the normal function files. This also prevents the scenario
                    // where someone reorganizes a function into a subdirectory and accidentally starts
                    // injecting a function that was previously filtered out.
                    const extname = path.extname(item.name);
                    const name = item.name
                        .replace(`${prefix}_`, "")
                        .replace(new RegExp(`${extname.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}$`), "");
                    if (shouldInjectFunction({ name })) {
                        return fs.cp(join(sourcePath, item.name), resolve(outDir, item.name), { recursive: true });
                    }
                });
                const results = await Promise.all(copyPromises);
                results.forEach((result, index) => {
                    if (result !== undefined) {
                        const functionName = edgeFunctions[index].name;
                        console.log(`Successfully injected edge function: ${functionName}`);
                    }
                });
            }
            catch (error) {
                console.error("Error copying files:", error);
            }
        };
    }
    /**
     * Injects functions into the user's site by copying injectables into the site's
     * `.netlify/functions-internal` directory.
     *
     * This was replaced by the `functions.generate` API (added in netlify-cli@2.2.2). We prefer that
     * API when available.
     */
    legacyInjectFunctions({ constants, prefix, shouldInjectFunction, }) {
        return async () => {
            const { INTERNAL_FUNCTIONS_SRC } = constants;
            if (!INTERNAL_FUNCTIONS_SRC) {
                throw new Error("INTERNAL_FUNCTIONS_SRC is not available for this Build Event Handler.");
            }
            // The internal functions directory will be in the site's base directory if defined, or in the
            // repository root.
            const outDir = join(INTERNAL_FUNCTIONS_SRC); //.netlify/functions-internal
            // create the edge functions directory if it doesn't exist
            await fs.mkdir(outDir, { recursive: true });
            // Find the edge functions we've copied over into the extension's build folder
            const sourcePath = path.join(path.dirname(fileURLToPath(import.meta.url)), "functions-bundled");
            try {
                const functions = await fs.readdir(sourcePath, { withFileTypes: true });
                const copyPromises = functions.map((item) => {
                    // Strip the prefix from the filename to match the user's original function name. Also
                    // strip off the file extension (if any) to that directories containing functions don't
                    // have special treatment vs. the normal function files. This also prevents the scenario
                    // where someone reorganizes a function into a subdirectory and accidentally starts
                    // injecting a function that was previously filtered out.
                    const extname = path.extname(item.name);
                    const name = item.name
                        .replace(`${prefix}_`, "")
                        .replace(new RegExp(`${extname.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}$`), "");
                    if (shouldInjectFunction({ name })) {
                        return fs.cp(join(sourcePath, item.name), resolve(outDir, item.name), { recursive: true });
                    }
                });
                const results = await Promise.all(copyPromises);
                results.forEach((result, index) => {
                    if (result !== undefined) {
                        const functionName = functions[index].name;
                        console.log(`Successfully injected function: ${functionName}`);
                    }
                });
            }
            catch (err) {
                console.error("Error copying files:", err);
            }
        };
    }
    async getGeneratedFunctions({ prefix, shouldInjectFunction, }) {
        const result = [];
        // Find the functions we've copied over into the extension's build folder
        const sourcePath = path.join(path.dirname(fileURLToPath(import.meta.url)), "functions");
        try {
            const functions = await fs.readdir(sourcePath, { withFileTypes: true });
            for (const item of functions) {
                // Strip the prefix from the filename to match the user's original function name. Also
                // strip off the file extension (if any) to that directories containing functions don't
                // have special treatment vs. the normal function files. This also prevents the scenario
                // where someone reorganizes a function into a subdirectory and accidentally starts
                // injecting a function that was previously filtered out.
                const extname = path.extname(item.name);
                const name = item.name
                    .replace(`${prefix}_`, "")
                    .replace(new RegExp(`${extname.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}$`), "");
                if (shouldInjectFunction({ name })) {
                    result.push({ path: resolve(sourcePath, item.name) });
                }
            }
        }
        catch (err) {
            console.error("Error copying files:", err);
        }
        return result;
    }
    /**
     * Used to add edge functions to the extension. Edge functions added using this method are
     * injected into a user's site whenever the user's site is built.
     *
     * @example
     * ```ts
     * extension.addEdgeFunctions(
     *   "src/edge-functions",
     *   {
     *     prefix: "my_extension",
     *     shouldInjectFunction: ({ name }) => name === "only-inject-this-one",
     *   },
     * );
     * ```
     */
    addEdgeFunctions(path, { prefix, shouldInjectFunction }) {
        if (typeof path !== "string" || path.length === 0) {
            throw new Error("Path must be a non-empty string.");
        }
        if (!prefix) {
            throw new Error("You must provide a prefix on the edgeFunctionsSettings when initializing the extension.");
        }
        this._edgeFunctionsSettings = {
            path,
            prefix,
            shouldInjectFunction: shouldInjectFunction ?? (() => true),
        };
        this.addFallbackBuildEventHandlers();
    }
    /**
     * Used to add functions to the extension. Functions added using this method are injected into a
     * user's site whenever the user's site is built.
     *
     * @example
     * ```ts
     * extension.addEdgeFunctions(
     *   "src/functions",
     *   {
     *     prefix: "my_extension",
     *     shouldInjectFunction: ({ name }) => name === "only-inject-this-one",
     *   },
     * );
     * ```
     */
    addFunctions(
    /**
     * A path to the directory containing functions. It should be a path relative to your
     * extension's base path, e.g. `src/edge-functions`.
     */
    path, { prefix, shouldInjectFunction }) {
        if (typeof path !== "string" || path.length === 0) {
            throw new Error("Path must be a non-empty string.");
        }
        if (!prefix) {
            throw new Error("You must provide a prefix on the functionsSettings when initializing the extension.");
        }
        this._functionsSettings = {
            path,
            prefix,
            shouldInjectFunction: shouldInjectFunction ?? (() => true),
        };
        this.addFallbackBuildEventHandlers();
    }
    addFallbackBuildEventHandlers() {
        if (!this._buildHooks.onPreBuild) {
            this.addBuildEventHandler("onPreBuild", () => {
                return;
            });
        }
        if (!this._buildHooks.onPreDev) {
            this.addBuildEventHandler("onPreDev", () => {
                return;
            });
        }
    }
    get buildHooks() {
        return this._buildHooks;
    }
    get handlers() {
        return this._handlers;
    }
    get baseHandler() {
        return async (event, context) => {
            const responseHeaders = {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "*",
                "Access-Control-Allow-Methods": "*",
            };
            // Fetch the path components from /api/<name> or /.netlify/functions/<name>
            // match with regex
            const routeRegex = /^(?:\/.netlify\/functions\/handler\/|\/api\/)([^/]+)(\/.*)?$/;
            const components = event.path.match(routeRegex);
            const name = components?.[1] ?? "not-found";
            const webhookHandler = name.startsWith("webhook");
            const handler = this._handlers[name];
            const isStaging = event.rawUrl?.includes(`.netlifystg.app`) ||
                event.path?.includes(`.netlifystg.app`);
            const jigsawUrl = isStaging
                ? EXTENSION_API_URL_STAGING
                : EXTENSION_API_URL_PROD;
            if (handler) {
                // Allow CORS preflight requests where the request does not come from the same origin
                if (event.httpMethod === "OPTIONS") {
                    return {
                        statusCode: 200,
                        headers: responseHeaders,
                    };
                }
                let nfToken = event.headers.cookie
                    ?.split(";")
                    .find((c) => c.includes("_nf-auth"))
                    ?.split("=")[1];
                if (!nfToken) {
                    nfToken = event.headers["netlify-token"];
                }
                if (!nfToken && !webhookHandler) {
                    return {
                        statusCode: 401,
                        headers: responseHeaders,
                        body: JSON.stringify({
                            error: "Unauthorized",
                        }),
                    };
                }
                const client = new NetlifyExtensionClient(nfToken ?? "", this._slug, { jigsawUrl });
                const { siteId, teamId, userId } = event.queryStringParameters ?? {};
                const { "provider-oauth-token": providerOAuthToken, "provider-oauth-tokens": providerOAuthTokens, } = event.headers;
                event.path = `/${name}${components?.[2] ?? ""}`;
                const hasConnector = false;
                const hasBuildEventHandler = Object.values(this._buildHooks).filter(Boolean).length > 0;
                let teamConfig = {};
                if (teamId) {
                    try {
                        const config = await client.getTeamConfiguration(teamId);
                        teamConfig = {
                            ...config,
                            config: config?.config ?? {},
                        };
                        if (teamConfig?.id) {
                            client.teamConfigId = teamConfig.id;
                        }
                    }
                    catch (err) {
                        console.error(err);
                    }
                }
                let siteConfig = {};
                if (siteId && teamId) {
                    try {
                        siteConfig =
                            (await client.getSiteConfiguration(teamId, siteId)) ?? {};
                        if (siteConfig?.id) {
                            client.siteConfigId = siteConfig.id;
                        }
                    }
                    catch (err) {
                        console.error(err);
                    }
                }
                const providerTokens = parseProviderTokens(providerOAuthTokens);
                try {
                    const response = await handler(event, {
                        ...context,
                        auth: {
                            netlifyToken: nfToken ?? null,
                            providerToken: providerOAuthToken ?? null,
                            providerTokens,
                        },
                        client,
                        hasBuildEventHandler,
                        hasConnector,
                        siteConfig,
                        siteId: siteId ?? null,
                        teamConfig,
                        teamId: teamId ?? null,
                        user: {
                            id: userId ?? null,
                        },
                    });
                    response.headers = {
                        ...responseHeaders,
                        ...response.headers,
                    };
                    return response;
                }
                catch (e) {
                    console.error(e);
                    return {
                        statusCode: 500,
                        headers: responseHeaders,
                        body: "An unhandled error occurred",
                    };
                }
            }
            return {
                statusCode: 404,
                headers: responseHeaders,
                body: JSON.stringify({
                    error: `Handler ${name} not found`,
                }),
            };
        };
    }
    getBuildConfig({ netlifyConfig, }) {
        const result = NetlifySDKConfigSchema.safeParse(netlifyConfig);
        if (!result.success) {
            throw new Error(`Your netlify.toml is invalid. Please fix the following errors and try again:\n\n${z.prettifyError(result.error)}`);
        }
        const extensionConfig = result.data.integrations.find(({ name }) => name === this._slug);
        if (typeof this.#parseBuildConfig === "function") {
            try {
                return this.#parseBuildConfig(extensionConfig?.config);
            }
            catch (err) {
                throw new Error(`The ${this._slug} extension configuration set in your netlify.toml is invalid. Reason:\n\n${err instanceof Error ? err.message : String(err)}`, { cause: err });
            }
        }
        // @ts-expect-error: This is not type safe, but it enables users who intentionally opt out of
        // type safety here.
        return extensionConfig?.config;
    }
    getBuildEventHandlersToRun() {
        return Object.entries(this._buildHooks).reduce((acc, [type, fn]) => {
            if (typeof fn === "function") {
                acc[type] = fn;
            }
            return acc;
        }, 
        // For wahtever reason, the generic doesn't work
        // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
        {});
    }
}
//# sourceMappingURL=index.js.map