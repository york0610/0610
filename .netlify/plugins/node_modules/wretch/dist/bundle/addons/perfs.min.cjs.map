{"version":3,"file":"perfs.min.cjs","sources":["../../../src/addons/perfs.ts"],"sourcesContent":["import type { WretchResponseChain, WretchAddon, Config } from \"../types.js\"\n\nexport type PerfCallback = (timing: any) => void\n\nexport interface PerfsAddon {\n  /**\n   * Performs a callback on the API performance timings of the request.\n   *\n   * Warning: Still experimental on browsers and node.js\n   */\n  perfs: <T, C extends PerfsAddon, R>(this: C & WretchResponseChain<T, C, R>, cb?: PerfCallback) => this,\n}\n\n/**\n * Adds the ability to measure requests using the Performance Timings API.\n *\n * Uses the Performance API\n * ([browsers](https://developer.mozilla.org/en-US/docs/Web/API/Performance_API) &\n * [node.js](https://nodejs.org/api/perf_hooks.html)) to expose timings related to\n * the underlying request.\n *\n * Browser timings are very accurate, node.js only contains raw measures.\n *\n * ```js\n * import PerfsAddon from \"wretch/addons/perfs\"\n *\n * // Use perfs() before the response types (text, json, ...)\n * wretch(\"...\")\n *   .addon(PerfsAddon())\n *   .get()\n *   .perfs((timings) => {\n *     // Will be called when the timings are ready.\n * console.log(timings.startTime);\n *   })\n *   .res();\n *\n * ```\n *\n * For node.js, there is a little extra work to do :\n *\n * ```js\n * // Node.js only\n * const { performance, PerformanceObserver } = require(\"perf_hooks\");\n *\n * wretch.polyfills({\n *   fetch: function (url, opts) {\n *     performance.mark(url + \" - begin\");\n *     return fetch(url, opts).then(res => {\n *       performance.mark(url + \" - end\");\n *       setTimeout(() => performance.measure(res.url, url + \" - begin\", url + \" - end\"), 0);\n *       return res;\n *     });\n *   },\n *   // other polyfillsâ€¦\n *   performance: performance,\n *   PerformanceObserver: PerformanceObserver,\n * });\n * ```\n */\nconst perfs: () => WretchAddon<unknown, PerfsAddon> = () => {\n  const callbacks = new Map<string, PerfCallback>()\n  let observer /*: PerformanceObserver | null*/ = null\n\n  const onMatch = (\n    entries /*: PerformanceObserverEntryList */,\n    name: string,\n    callback: PerfCallback,\n    performance: typeof globalThis.performance\n  ) => {\n    if (!entries.getEntriesByName)\n      return false\n    const matches = entries.getEntriesByName(name)\n    if (matches && matches.length > 0) {\n      callback(matches.reverse()[0])\n      if (performance.clearMeasures)\n        performance.clearMeasures(name)\n      callbacks.delete(name)\n\n      if (callbacks.size < 1) {\n        observer.disconnect()\n        if (performance.clearResourceTimings) {\n          performance.clearResourceTimings()\n        }\n      }\n      return true\n    }\n    return false\n  }\n\n  const initObserver = (\n    performance: (typeof globalThis.performance) | null | undefined,\n    performanceObserver /*: (typeof PerformanceObserver) | null | undefined */\n  ) => {\n    if (!observer && performance && performanceObserver) {\n      observer = new performanceObserver(entries => {\n        callbacks.forEach((callback, name) => {\n          onMatch(entries, name, callback, performance)\n        })\n      })\n      if (performance.clearResourceTimings) {\n        performance.clearResourceTimings()\n      }\n    }\n\n    return observer\n  }\n\n  const monitor = (\n    name: string | null | undefined,\n    callback: PerfCallback | null | undefined,\n    config: Config\n  ) => {\n    if (!name || !callback)\n      return\n\n    const performance = config.polyfill(\"performance\", false)\n    const performanceObserver = config.polyfill(\"PerformanceObserver\", false)\n\n    if (!initObserver(performance, performanceObserver))\n      return\n\n    if (!onMatch(performance, name, callback, performance)) {\n      if (callbacks.size < 1)\n        observer.observe({ entryTypes: [\"resource\", \"measure\"] })\n      callbacks.set(name, callback)\n    }\n  }\n\n  return {\n    resolver: {\n      perfs(cb) {\n        this._fetchReq\n          .then(() =>\n            monitor(this._wretchReq._url, cb, this._wretchReq._config)\n          )\n          .catch(() => {/* swallow */ })\n        return this\n      },\n    }\n  }\n}\n\nexport default perfs\n"],"names":["callbacks","Map","observer","onMatch","entries","name","callback","performance","getEntriesByName","matches","length","reverse","clearMeasures","delete","size","disconnect","clearResourceTimings","resolver","perfs","cb","this","_fetchReq","then","config","polyfill","performanceObserver","forEach","initObserver","observe","entryTypes","set","monitor","_wretchReq","_url","_config","catch"],"mappings":"4BA2DsD,KACpD,MAAMA,EAAY,IAAIC,IACtB,IAAIC,EAA4C,KAEhD,MAAMC,EAAU,CACdC,EACAC,EACAC,EACAC,KAEA,IAAKH,EAAQI,iBACX,OAAO,EACT,MAAMC,EAAUL,EAAQI,iBAAiBH,GACzC,OAAII,GAAWA,EAAQC,OAAS,GAC9BJ,EAASG,EAAQE,UAAU,IACvBJ,EAAYK,eACdL,EAAYK,cAAcP,GAC5BL,EAAUa,OAAOR,GAEbL,EAAUc,KAAO,IACnBZ,EAASa,aACLR,EAAYS,sBACdT,EAAYS,wBAGT,GAEF,CAAK,EA0Cd,MAAO,CACLC,SAAU,CACRC,MAAMC,GAMJ,OALAC,KAAKC,UACFC,MAAK,IAzBE,EACdjB,EACAC,EACAiB,KAEA,IAAKlB,IAASC,EACZ,OAEF,MAAMC,EAAcgB,EAAOC,SAAS,cAAe,GA1BhC,EACnBjB,EACAkB,MAEKvB,GAAYK,GAAekB,IAC9BvB,EAAW,IAAIuB,GAAoBrB,IACjCJ,EAAU0B,SAAQ,CAACpB,EAAUD,KAC3BF,EAAQC,EAASC,EAAMC,EAAUC,EAAY,GAC7C,IAEAA,EAAYS,sBACdT,EAAYS,wBAITd,GAcFyB,CAAapB,EAFUgB,EAAOC,SAAS,sBAAuB,MAK9DrB,EAAQI,EAAaF,EAAMC,EAAUC,KACpCP,EAAUc,KAAO,GACnBZ,EAAS0B,QAAQ,CAAEC,WAAY,CAAC,WAAY,aAC9C7B,EAAU8B,IAAIzB,EAAMC,IACrB,EAQOyB,CAAQX,KAAKY,WAAWC,KAAMd,EAAIC,KAAKY,WAAWE,WAEnDC,OAAM,SACFf,IACR,GAEJ"}