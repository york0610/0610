import { execSync } from "node:child_process";
import fs from "node:fs/promises";
import path, { resolve, parse } from "node:path";
import chalk from "chalk";
import { build as esbuild } from "esbuild";
import fsext from "fs-extra";
import { outdent as javascript } from "outdent";
import { getPackageVersion } from "../extension/package-version.js";
import { esbuildPluginSeenNodeModules, getDefaultEsbuildConfig, } from "./commands/build.js";
import { removeBundledDepsFromPackageJsonContents } from "./util.js";
export { buildExtensionUI, } from "./build/build_extension_ui.js";
export const generateBuildEventHandler = async (extension, config, opts) => {
    if (Object.values(extension.buildHooks).every((value) => !value)) {
        console.log(chalk.white("No build event handlers found."));
        return;
    }
    const { outDir, cwd } = opts;
    const extensionPackageJson = await fsext.readJSON(resolve(cwd, "package.json"));
    await fsext.ensureDir(resolve(outDir, "build"));
    const esbuildSeenModules = esbuildPluginSeenNodeModules({
        markAsExternal: false,
    });
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [resolve(outDir, "index.js")],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile: resolve(outDir, "build/extension.js"),
        plugins: [esbuildSeenModules.plugin],
    };
    await esbuild(esbuildOptions);
    let exportedPluginCode = javascript `
    import { extension } from "./extension.js";
    extension._slug = "${config.slug}";\n
    ${config.hostSiteId ? `extension._hostSiteId = "${config.hostSiteId}";\n` : ""}
  `;
    exportedPluginCode += javascript `
    export default function NetlifyExtensionBuildPlugin() {
      return extension.getBuildEventHandlersToRun();
    };`;
    const buildDir = resolve(outDir, "build");
    // Build any internal functions. We extract the module specifiers that were
    // imported by the function because they must be listed as dependencies of
    // the buildhooks package.
    const { nodeModulesImports } = await buildInternalFunctions({
        extension,
        outDir: path.join(outDir, "build/functions"),
        type: "function",
        config,
        markAsExternal: true,
    });
    // Build legacy functions. (These functions use esbuild to inline all externals (node_module deps)
    // and are meant to be injected only by CLI/@netlify/build versions that don't support the
    // `functions.generate` API.
    //
    // Functions injected this way do not support native dependencies well, nor dependencies that do
    // dynamic things like load files from the filesystem that are shipped in the the dependency
    // tarball.
    await buildInternalFunctions({
        extension,
        outDir: path.join(outDir, "build/functions-bundled"),
        type: "function",
        config,
        markAsExternal: false,
    });
    // build any internal edge functions
    await buildInternalFunctions({
        extension,
        outDir: path.join(outDir, "build/edge-functions"),
        type: "edge",
        config,
        markAsExternal: true,
    });
    const requiredNodeModules = new Set([
        ...esbuildSeenModules.nodeModulesImports,
        ...nodeModulesImports,
    ]);
    const normalizedPackageJSON = removeBundledDepsFromPackageJsonContents(extensionPackageJson, requiredNodeModules);
    // generate random 5 character string
    const randomString = Math.random().toString(36).substring(2, 7);
    const version = `0.0.0-${randomString}`;
    const name = `${config.slug}-buildhooks`;
    if (fsext.existsSync(resolve(cwd, "assets"))) {
        fsext.copySync(resolve(cwd, "assets"), resolve(buildDir, "assets"));
    }
    await fsext.writeFile(resolve(buildDir, "index.js"), exportedPluginCode);
    await fsext.writeJSON(resolve(buildDir, "package.json"), {
        main: "index.js",
        type: "module",
        version,
        name,
        dependencies: {
            ...normalizedPackageJSON.dependencies,
            "@netlify/sdk": 
            // Use the version of the SDK defined in the extension's package.json. When consumed by an
            // end user, this should match the version returned by `getPackageVersion()`. During a test
            // or in a `npm install ../local-sdk-path` development workflow, however, we need to point
            // at the SDK code that's not yet published in the resulting tarball.
            extensionPackageJson?.dependencies?.["@netlify/sdk"].replace("link:", "file:") ?? getPackageVersion(),
        },
        devDependencies: {
            ...normalizedPackageJSON.devDependencies,
        },
    });
    await fsext.writeFile(resolve(buildDir, "manifest.yml"), `name: ${name}`);
    execSync("npm pack", { cwd: buildDir });
    const packedFile = `${name
        .replaceAll("@", "")
        .replaceAll("/", "-")}-${version}.tgz`;
    await fsext.ensureDir(resolve(outDir, "site/static/packages"));
    fsext.copyFileSync(resolve(buildDir, packedFile), resolve(outDir, "site/static/packages", "buildhooks.tgz"));
};
export const validateDetailsFile = async ({ src, }) => {
    try {
        await fs.access(src, fs.constants.R_OK);
        return { success: true };
    }
    catch (err) {
        return {
            success: false,
            error: new Error(`No \`details.md\` file exists at ${src}. Please create a \`details.md\` file and re-run this command.`, { cause: err }),
        };
    }
};
export const buildDetailsFile = async ({ dest, src, }) => {
    await fs.mkdir(path.dirname(dest), { recursive: true });
    await fs.cp(src, dest);
};
export const copySiteAssets = async ({ cwd, outDir, }) => {
    const assetsDir = resolve(cwd, "assets");
    const outAssetsDir = resolve(outDir, "site/static/ui/assets");
    await fsext.ensureDir(outAssetsDir);
    if (fsext.existsSync(assetsDir)) {
        console.log(chalk.white(`Copying assets from ${assetsDir} to ${outAssetsDir}...`));
        fsext.copySync(assetsDir, outAssetsDir);
        console.log(chalk.white(`Copied assets from ${assetsDir} to ${outAssetsDir}.`));
    }
};
const bundleEdgeFunction = (config) => async (srcPath, outPath) => {
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [srcPath],
        bundle: true,
        format: "esm",
        platform: "browser",
        outfile: outPath,
        plugins: [
            {
                name: "dependency-check",
                setup(build) {
                    build.onResolve({ filter: /.*/ }, (args) => {
                        // Check if the path is not a URL and not a relative path
                        if (!args.path.startsWith("http://") &&
                            !args.path.startsWith("https://") &&
                            !args.path.startsWith(".") &&
                            !args.path.startsWith("/")) {
                            throw new Error(`Invalid dependency found: ${args.path}. Edge Functions injected through extensions can only import local files, deno modules and npm modules with URL imports.`);
                        }
                        return null;
                    });
                },
            },
        ],
    };
    await esbuild(esbuildOptions);
    return {
        nodeModulesImports: new Set(),
    };
};
const copyFunctionDirectory = async (source, target, bundleFunction) => {
    await fsext.ensureDir(target);
    const items = fsext.readdirSync(source, { withFileTypes: true });
    const nodeModulesImports = [];
    items.forEach(async (item) => {
        const srcPath = resolve(source, item.name);
        const targetPath = resolve(target, item.name);
        if (item.isDirectory()) {
            const bundleResult = await copyFunctionDirectory(srcPath, targetPath, bundleFunction);
            nodeModulesImports.push(...bundleResult.nodeModulesImports);
        }
        else {
            const bundleResult = await bundleFunction(srcPath, targetPath);
            nodeModulesImports.push(...bundleResult.nodeModulesImports);
        }
    });
    return {
        nodeModulesImports: new Set(nodeModulesImports),
    };
};
const buildInternalFunctions = async ({ extension, outDir, type, config, markAsExternal, }) => {
    const settings = type === "function"
        ? extension._functionsSettings
        : extension._edgeFunctionsSettings;
    const nodeModulesImports = [];
    if (settings) {
        const { path: internalFunctionsPath, prefix: internalFunctionsPrefix } = settings;
        if (internalFunctionsPath && internalFunctionsPrefix) {
            await fsext.ensureDir(internalFunctionsPath);
            const internalFunctions = await fsext.readdir(internalFunctionsPath);
            if (!internalFunctions || internalFunctions.length === 0) {
                throw new Error(`No internal ${type === "edge" ? "edge functions" : "functions"} found.`);
            }
            for (const fn of internalFunctions || []) {
                const newFilePath = resolve(outDir, `${internalFunctionsPrefix}_${parse(fn).base}`);
                const oldFilePath = resolve(internalFunctionsPath, fn);
                try {
                    const stats = await fsext.stat(oldFilePath);
                    if (stats.isFile()) {
                        await fsext.ensureFile(newFilePath);
                        const bundleResult = await bundleFunction(config, markAsExternal)(oldFilePath, newFilePath);
                        nodeModulesImports.push(...bundleResult.nodeModulesImports);
                    }
                    else if (stats.isDirectory()) {
                        const bundleResult = await copyFunctionDirectory(oldFilePath, newFilePath, type === "function"
                            ? bundleFunction(config, markAsExternal)
                            : bundleEdgeFunction(config));
                        nodeModulesImports.push(...bundleResult.nodeModulesImports);
                    }
                }
                catch (err) {
                    console.error(err);
                }
            }
        }
    }
    return {
        nodeModulesImports: new Set(nodeModulesImports),
    };
};
const bundleFunction = (config, markAsExternal) => {
    return async (srcPath, outPath) => {
        const esbuildSeenModules = esbuildPluginSeenNodeModules({ markAsExternal });
        const esbuildOptions = {
            ...getDefaultEsbuildConfig(config),
            entryPoints: [srcPath],
            bundle: true,
            format: "esm",
            platform: "node",
            plugins: [esbuildSeenModules.plugin],
            outfile: outPath,
        };
        await esbuild(esbuildOptions);
        return {
            nodeModulesImports: esbuildSeenModules.nodeModulesImports,
        };
    };
};
//# sourceMappingURL=index.js.map