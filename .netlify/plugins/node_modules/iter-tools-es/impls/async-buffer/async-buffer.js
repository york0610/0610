const {
  curry
} = require('../../internal/curry.js');

const {
  asyncCallReturn
} = require('../../internal/async-iterable.js');

const {
  AsyncIterableIterator
} = require('../../internal/async-iterable-iterator.js');

const {
  CircularBuffer
} = require('../../internal/circular-buffer.js');

const {
  isPositiveInteger
} = require('../../internal/number.js');

const {
  isAsyncIterable
} = require('../is-async-iterable/is-async-iterable.js');

const {
  isIterable
} = require('../../internal/iterable.js');

async function* empty() {}

function getIterator(iterable) {
  if (iterable == null) {
    return empty();
  } else if (isAsyncIterable(iterable)) {
    return iterable[Symbol.asyncIterator]();
  } else if (isIterable(iterable)) {
    return iterable[Symbol.iterator]();
  } else {
    throw new Error(`asyncBuffer expected an iterable but received ${iterable}.`);
  }
}

class Bufferator extends AsyncIterableIterator {
  constructor(iterable, concurrency) {
    super();
    this.iterator = getIterator(iterable);
    this.buffer = new CircularBuffer(concurrency);

    while (!this.buffer.isFull()) {
      this.buffer.push(Promise.resolve(this.iterator.next()));
    }
  }

  async next() {
    const {
      buffer,
      iterator
    } = this;
    return await buffer.push(Promise.resolve(iterator.next()));
  }

  async return() {
    return await asyncCallReturn(this.iterator);
  }

}

exports.Bufferator = Bufferator;

function __asyncBuffer(source, n) {
  return new Bufferator(source, n);
}

exports.__asyncBuffer = __asyncBuffer;
const asyncBuffer = /*#__PURE__*/curry(function asyncBuffer(n, source) {
  if (n === undefined) return;

  if (n !== Infinity && !isPositiveInteger(n)) {
    throw new Error('Concurrency must be an integer > 0');
  } else if (n > 1024) {
    throw new Error('Concurrency argument to asyncBuffer must be <= 1024');
  }

  return __asyncBuffer(source, n);
});
exports.asyncBuffer = asyncBuffer;