import path from "node:path";
import os from "node:os";
import chalk from "chalk";
import fsExtraPkg from "fs-extra";
const { existsSync, readJSON } = fsExtraPkg;
export const getExtensionModule = async (builtPath, directory = process.cwd()) => {
    try {
        const extensionModule = await import(builtPath);
        const { extension, integration } = extensionModule;
        if (!extension) {
            const { sourceFilePath } = await getExtensionBuildInfo({
                cwd: directory,
            });
            throw new Error(`Your extension must be a named export in your main TS file (at ${sourceFilePath}).

For example:

import { NetlifyExtension } from "@netlify/sdk";
const extension = new NetlifyExtension();

export { extension } // <-- this is required.

${integration ? `Found a deprecated "integration" export in this file. Please rename this export to "extension"` : ``}`);
        }
        return extension;
    }
    catch (e) {
        console.log(chalk.red("Could not load module"));
        if (e.message) {
            console.error(e.message);
        }
        throw e;
    }
};
export const getExtensionBuildInfo = async ({ cwd, outDirOveride, }) => {
    const extensionPackageJson = await readJSON(path.resolve(cwd, "package.json"));
    // main points to our entrypoint
    const { main } = extensionPackageJson;
    if (!main) {
        throw new Error(`${extensionPackageJson.name || `package`} must set a "main" property in package.json`);
    }
    const sourceFilePath = path.resolve(cwd, main);
    if (!existsSync(sourceFilePath)) {
        throw new Error(`${extensionPackageJson.name || `package`}'s main property in package.json points to a non-existing file`);
    }
    const outDir = outDirOveride || path.resolve(`${cwd}/.ntli`);
    const builtPath = `${outDir}/index.js`;
    const packageName = extensionPackageJson.name;
    return {
        extensionPackageJson,
        sourceFilePath,
        builtPath,
        outDir,
        packageName,
    };
};
export function getDepNames(packageJsonContents) {
    const deps = {
        ...(packageJsonContents.dependencies || {}),
        ...(packageJsonContents.devDependencies || {}),
    };
    return Object.keys(deps);
}
export function removeBundledDepsFromPackageJsonContents(packageJsonContents, importedNodeModules) {
    function removeExtraDeps(deps) {
        return Object.fromEntries(Object.entries(deps || {}).filter(([depName]) => {
            return (
            // if no imported modules list is provided, include all deps
            !importedNodeModules?.size ||
                // if it is, then only include the dep if it's been imported somewhere
                importedNodeModules.has(depName));
        }));
    }
    return {
        ...packageJsonContents,
        dependencies: removeExtraDeps(packageJsonContents.dependencies),
        devDependencies: removeExtraDeps(packageJsonContents.devDependencies),
    };
}
export const getSettings = () => {
    const settingsPath = `${os.homedir()}/.netlify/ntli.json`;
    if (!fsExtraPkg.existsSync(settingsPath)) {
        return {};
    }
    const settings = fsExtraPkg.readJSONSync(settingsPath);
    return settings;
};
export const updateSettings = (newSettings) => {
    const settingsPath = `${os.homedir()}/.netlify/ntli.json`;
    const settings = {
        ...(getSettings() || {}),
        ...newSettings,
    };
    fsExtraPkg.ensureFileSync(settingsPath);
    fsExtraPkg.writeJSONSync(settingsPath, settings);
};
//# sourceMappingURL=util.js.map