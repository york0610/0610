import { initTRPC, TRPCError } from "@trpc/server";
/**
 * TODO(ndhoule): Expose this as part of sdk--ui-functions public api
 * TODO(ndhoule): Document me
 * TODO(ndhoule): Replace this with a default custom error formatter
 *
 * @unstable
 * @internal
 */
export const createMaskInternalErrorsPlugin = () => {
    const t = initTRPC.create();
    return t.middleware(async ({ next }) => {
        try {
            return await next();
        }
        catch (err) {
            if (err instanceof TRPCError) {
                throw err;
            }
            throw new TRPCError({
                cause: err,
                code: "INTERNAL_SERVER_ERROR",
                message: "Internal server error",
            });
        }
    });
};
/**
 * TODO(ndhoule): Expose this as part of sdk--ui-functions public api
 * TODO(ndhoule): Document me
 * TODO(ndhoule): Consider replacing these checks with a Zod schema
 *
 * @unstable
 * @internal
 */
export const createRequireTeamIdPlugin = () => {
    const t = initTRPC.context().create();
    return t.middleware(async ({ ctx, next }) => {
        if (ctx.teamId == null || ctx.teamId.trim() === "") {
            throw new TRPCError({ code: "BAD_REQUEST", message: "teamId required" });
        }
        return next({
            ctx: {
                teamId: ctx.teamId,
            },
        });
    });
};
/**
 * TODO(ndhoule): Expose this as part of sdk--ui-functions public api
 * TODO(ndhoule): Document me
 * TODO(ndhoule): Consider replacing these checks with a Zod schema
 *
 * @unstable
 * @internal
 */
export const createRequireSiteIdPlugin = () => {
    const t = initTRPC.context().create();
    return t.middleware(async ({ ctx, next }) => {
        if (ctx.siteId == null || ctx.siteId.trim() === "") {
            throw new TRPCError({ code: "BAD_REQUEST", message: "siteId required" });
        }
        return next({
            ctx: {
                siteId: ctx.siteId,
            },
        });
    });
};
/**
 * TODO(ndhoule): Expose this as part of sdk--ui-functions public api
 * TODO(ndhoule): Document me
 * TODO(ndhoule): Consider replacing these checks with a Zod schema
 *
 * @unstable
 * @internal
 */
export const createRequireDataLayerIdPlugin = () => {
    const t = initTRPC
        .context()
        .create();
    return t.middleware(async ({ ctx, next }) => {
        if (ctx.dataLayerId == null || ctx.dataLayerId.trim() === "") {
            throw new TRPCError({
                code: "BAD_REQUEST",
                message: "dataLayerId required",
            });
        }
        return next({
            ctx: {
                dataLayerId: ctx.dataLayerId,
            },
        });
    });
};
/**
 * TODO(ndhoule): Expose this as part of sdk--ui-functions public api
 * TODO(ndhoule): Document me
 * TODO(ndhoule): Consider replacing these checks with a Zod schema
 *
 * @unstable
 * @internal
 */
export const createRequireAuthenticationPlugin = () => {
    return initTRPC
        .context()
        .create()
        .middleware(async ({ ctx, next }) => {
        const netlifyToken = (ctx.auth?.netlifyToken ?? "").trim();
        const providerToken = (ctx.auth?.providerToken ?? "").trim();
        // We check for this even though it should never happen under normal circumstances. Users should
        // always be logged in and capable of retrieving a Netlify token.
        if (netlifyToken === "") {
            throw new TRPCError({
                code: "UNAUTHORIZED",
                message: "Netlify API token missing",
            });
        }
        if (providerToken === "") {
            throw new TRPCError({
                code: "UNAUTHORIZED",
                message: "Provider API token missing",
            });
        }
        return next({
            ctx: {
                auth: {
                    ...ctx.auth,
                    netlifyToken,
                    providerToken,
                },
            },
        });
    });
};
//# sourceMappingURL=main.js.map