import chalk from "chalk";
import { execa, ExecaError } from "execa";
import parseArgv from "string-argv";
import { openExtensionDevUrl } from "../dev/open_extension_dev_url.js";
export const buildExtensionUI = async (ctx, options) => {
    let command;
    switch (options.mode) {
        case "dev":
            command = {
                file: "netlify",
                args: [
                    "dev",
                    "--no-open",
                    "--command",
                    options.command?.dev ?? "vite dev",
                    ...(options.previewURL ? ["--live", "integration-preview"] : []),
                ],
            };
            break;
        case "build":
            command = {
                file: "netlify",
                args: [
                    "build",
                    ...((options.siteId ?? "") === "" ? ["--offline"] : []),
                ],
            };
            break;
        default:
            throw new Error(`Unsupported Extension UI build mode: ${options.mode}`);
    }
    try {
        await execa(command.file, [
            ...command.args,
            // Inject extra arguments, which may be useful in testing environments (e.g. --offline)
            ...parseArgv(process.env.NETLIFY_SDK_NETLIFY_BIN_ARGS ?? ""),
        ], {
            cancelSignal: ctx.signal,
            cwd: options.cwd,
            env: { NETLIFY_EXTENSION_SUB_BUILD: "true" },
            // When specified, execa will attempt to prefer a locally installed copy (one installed to a
            // `node_modules/.bin` path) of `command.file` over whatever global one exists in the user's
            // PATH. This is useful for a test environment, where we don't want to e.g. use the
            // developer's global `netlify` install.
            preferLocal: process.env.NETLIFY_SDK_USE_LOCAL_NETLIFY_BIN === "true",
            stderr: [
                function* (line) {
                    if (typeof line === "string") {
                        yield chalk.red(options.meta.name || options.meta.slug) +
                            `: ${line}`;
                    }
                },
                ctx.stderr ?? undefined,
            ],
            stdout: [
                function* (line) {
                    if (typeof line === "string") {
                        if (line.includes("◈ Server now ready on") ||
                            line.includes("Local dev server ready:")) {
                            /**
                             * http:\/\/ matches the start of the URL.
                             * \S+? matches one or more non-whitespace characters
                             * \s matches the first whitespace character after the URL, which is used as the stopping point.
                             */
                            let url = "";
                            const match = /(◈ Server now ready on|Local dev server ready:) (?<url>https?:\/\/\S+?)\s/.exec(line);
                            if (typeof match?.groups?.url === "string") {
                                url = match.groups.url;
                            }
                            if (url !== "" && options.open) {
                                openExtensionDevUrl(url, options.slug ?? options.meta.slug);
                            }
                        }
                        yield chalk.yellow(options.meta.name || options.meta.slug) +
                            `: ${line}`;
                    }
                },
                ctx.stdout ?? undefined,
            ],
        });
    }
    catch (err) {
        if (err instanceof ExecaError) {
            if (err.isCanceled || err.isGracefullyCanceled) {
                // This is an expected "failure" mode
                return;
            }
            if (err.code === "ENOENT") {
                throw new Error("Netlify CLI not found. Please install it with `npm i -g netlify-cli`");
            }
        }
        throw err;
    }
};
//# sourceMappingURL=build_extension_ui.js.map