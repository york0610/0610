{"version":3,"file":"Dropdown.js","sources":["../../../../src/components/Form/Fields/Dropdown.tsx"],"sourcesContent":["import { useCallback } from \"react\";\nimport { Controller, type Path, useFormContext } from \"react-hook-form\";\nimport { getInitialSelectedOption } from \"../../Dropdown/Dropdown.js\";\nimport {\n  Dropdown as BaseDropdown,\n  type DropdownOption,\n  type DropdownProps as BaseDropdownProps,\n} from \"../../Dropdown/main.js\";\n\nexport { type DropdownOption } from \"../../Dropdown/main.js\";\n\nexport type DropdownProps<T> = Omit<BaseDropdownProps<T>, \"onChange\"> & {\n  name: string;\n};\n\n/**\n * Dropdowns let users select from a list of options.\n *\n * <!-- TODO(ndhoule): Add a screenshot here -->\n *\n * @param props\n * @see {@link Form}\n * @internal\n * @example\n * ```ts\n * import { Dropdown, Form } from \"@netlify/sdk/react/components\";\n *\n * <Form>\n *   <Dropdown\n *     name=\"favoriteDog\"\n *     options=[\n *       { label: \"Pomeranian\", value: \"pomeranian\" },\n *       { label: \"Golden Retriever\", value: \"golden-retriever\" },\n *       { label: \"Doge\", value: \"shiba-inu\" },\n *     ]\n *   />\n * </Form>\n * ```\n */\nexport const Dropdown = <\n  T,\n  FieldValues extends Record<string, unknown> = Record<string, unknown>,\n>({\n  name,\n  options = [],\n  initialSelectedOption,\n  ...otherProps\n}: DropdownProps<T>) => {\n  const { control } = useFormContext<FieldValues>();\n\n  const defaultOption = getInitialSelectedOption(\n    [{ label: <>&nbsp;</>, value: undefined }, ...options],\n    initialSelectedOption,\n  );\n\n  return (\n    <Controller\n      name={name as unknown as Path<FieldValues>}\n      control={control}\n      // @ts-expect-error FIXME(ndhoule): It's possible to fix this type error, it's just more work\n      // than it's worth right now\n      defaultValue={defaultOption?.value}\n      render={({ field: { onChange: originalOnChange, value, ...field } }) => {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const onChange = useCallback(\n          (value: DropdownOption<T> | null) => {\n            originalOnChange(value?.value);\n          },\n          [originalOnChange],\n        );\n\n        return (\n          <BaseDropdown\n            onChange={onChange}\n            {...field}\n            initialSelectedOption={initialSelectedOption}\n            // Switch the component into controlled mode, allowing react-hook-form to be the source\n            // of truth. This makes functionality like the form context's reset() method work.\n            //\n            // @ts-expect-error FIXME(ndhoule): It's possible to fix this type error, it's just more\n            // work than it's worth right now\n            selectedItem={\n              options.find((option) => option.value === value) ?? defaultOption\n            }\n            options={options}\n            {...otherProps}\n          />\n        );\n      }}\n    />\n  );\n};\n"],"names":["value","BaseDropdown"],"mappings":";;;;AAuCO,MAAM,WAAW,CAGtB;AAAA,EACA;AAAA,EACA,UAAU,CAAA;AAAA,EACV;AAAA,EACA,GAAG;AACL,MAAwB;AACtB,QAAM,EAAE,QAAA,IAAY,eAAA;AAEpB,QAAM,gBAAgB;AAAA,IACpB,CAAC,EAAE,OAAO,oBAAA,UAAA,EAAE,UAAA,IAAA,CAAM,GAAK,OAAO,OAAA,GAAa,GAAG,OAAO;AAAA,IACrD;AAAA,EAAA;AAGF,SACE;AAAA,IAAC;AAAA,IAAA;AAAA,MACC;AAAA,MACA;AAAA,MAGA,cAAc,+CAAe;AAAA,MAC7B,QAAQ,CAAC,EAAE,OAAO,EAAE,UAAU,kBAAkB,OAAO,GAAG,MAAA,QAAc;AAEtE,cAAM,WAAW;AAAA,UACf,CAACA,WAAoC;AACnC,6BAAiBA,iCAAO,KAAK;AAAA,UAC/B;AAAA,UACA,CAAC,gBAAgB;AAAA,QAAA;AAGnB,eACE;AAAA,UAACC;AAAAA,UAAA;AAAA,YACC;AAAA,YACC,GAAG;AAAA,YACJ;AAAA,YAMA,cACE,QAAQ,KAAK,CAAC,WAAW,OAAO,UAAU,KAAK,KAAK;AAAA,YAEtD;AAAA,YACC,GAAG;AAAA,UAAA;AAAA,QAAA;AAAA,MAGV;AAAA,IAAA;AAAA,EAAA;AAGN;"}