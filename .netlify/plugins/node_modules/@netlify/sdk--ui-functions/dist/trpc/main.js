/**
 * @module @netlify/sdk/ui/functions/trpc
 */
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { createNetlifySDKContext, } from "../sdk_context.js";
/**
 * `createNetlifyTRPCHandler` accepts a tRPC router and installs Netlify SDK-specific extensions
 * onto it.
 *
 * When using tRPC to build Extension UIs, you must wrap your tRPC router using this function.
 *
 * @param options
 * @example
 * ```ts
 * import { createNetlifyTRPCHandler } from "@netlify/sdk/ui/functions/trpc";
 * import { appRouter } from "./router.js";
 *
  const handler = createNetlifyTRPCHandler({
    endpoint: "/api/trpc",
    router: appRouter,
  });
 * ```
 */
export const createNetlifyTRPCHandler = ({ router, endpoint, createContext, }) => {
    return async (req, netlifyContext) => {
        return fetchRequestHandler({
            // TODO(ndhoule): Honestly, this is a little funky. Maybe it's better to pass a context
            // customizer function that is expected to return the full context passed to trpc?
            createContext: (options) => {
                const netlifySDKContext = createNetlifySDKContext({
                    req: options.req,
                });
                const customContext = createContext?.({
                    ...options,
                    context: { ...netlifyContext, ...netlifySDKContext },
                }) ?? {};
                return {
                    ...netlifyContext,
                    ...netlifySDKContext,
                    ...customContext,
                };
            },
            // TODO(ndhoule): Is it possible to eliminate the need for integrators to pass this? (Probably no.)
            endpoint,
            onError: (opts) => {
                console.error("TRPC request failed", { error: opts.error });
            },
            req,
            router,
        });
    };
};
//# sourceMappingURL=main.js.map