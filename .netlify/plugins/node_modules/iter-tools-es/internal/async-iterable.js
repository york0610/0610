const {
  isAsyncIterable
} = require('../impls/is-async-iterable/is-async-iterable.js');

const {
  isAsyncLoopable
} = require('../impls/is-async-loopable/is-async-loopable.js');

const {
  isAsyncWrappable
} = require('../impls/is-async-wrappable/is-async-wrappable.js');

const {
  asyncNullableWrap: asyncWrap
} = require('./async-wrap.js');

const {
  BaseIterableIterator,
  IterableIterator
} = require('./iterable.js');

const {
  variadicCurryWithValidation
} = require('./curry.js');

const {
  __iterate
} = require('./symbols.js');

exports.asyncWrap = asyncWrap;
exports.asyncIsIterable = isAsyncIterable;
exports.asyncIsLoopable = isAsyncLoopable;
exports.asyncIsWrappable = isAsyncWrappable;

async function asyncCallReturn(iterator) {
  if ('return' in iterator) await iterator.return();
}

exports.asyncCallReturn = asyncCallReturn;

function asyncEnsureIterable(value) {
  if (!isAsyncWrappable(value)) {
    if (typeof value.next === 'function') {
      throw new TypeError('iter-tools received a value that looked like an iterator but was not async iterable. Get help fixing this: https://github.com/iter-tools/iter-tools/wiki/Making-iterators-iterable#async-iterators');
    } else throw new TypeError('Expected an async iterable, sync iterable, null or undefined');
  } else if (isAsyncIterable(value)) {
    return value;
  } else {
    return asyncWrap(value);
  }
}

exports.asyncEnsureIterable = asyncEnsureIterable;

function AsyncIterableIterator(...args) {
  BaseIterableIterator.apply(this, args);
}

exports.AsyncIterableIterator = AsyncIterableIterator;
AsyncIterableIterator.prototype = Object.assign(Object.create(BaseIterableIterator.prototype), {
  constructor: AsyncIterableIterator,

  [Symbol.asyncIterator]() {
    return this[__iterate]();
  }

});

function makeFunctionConfig(fn, fnConfig = {}) {
  const {
    validateArgs = _ => {},
    variadic = false,
    reduces = false,
    growRight = false,
    minArgs = fn.length - 1,
    maxArgs = fn.length - 1,
    forceSync = false,
    applyOnIterableArgs = asyncEnsureIterable
  } = fnConfig;
  return {
    fn,
    validateArgs,
    variadic,
    reduces,
    growRight,
    minArgs,
    maxArgs,
    isIterable: isAsyncWrappable,
    iterableType: 'asyncIterable',
    applyOnIterableArgs,
    IterableClass: forceSync ? IterableIterator : AsyncIterableIterator
  };
}

async function asyncCache(it) {
  const arr = [];

  for await (const value of it) arr.push(value);

  return asyncWrapWithIterableIterator(asyncWrap)(arr);
}

exports.asyncCache = asyncCache;

function asyncWrapWithIterableIterator(fn, {
  validateArgs = _ => _
} = {}) {
  return (...args) => {
    validateArgs(args);
    return new AsyncIterableIterator(fn, args);
  };
}

exports.asyncWrapWithIterableIterator = asyncWrapWithIterableIterator;

const asyncIterableCurry = (fn, config) => {
  return variadicCurryWithValidation(makeFunctionConfig(fn, config));
};

exports.asyncIterableCurry = asyncIterableCurry;