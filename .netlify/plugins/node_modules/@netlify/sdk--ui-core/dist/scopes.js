/*
 * This file contains the list of permission scopes supported by extensions and various helper
 * functions for using scopes.
 *
 * The enums and helpers in this file are carefully structured to use TypeScript's exhaustive switch
 * case rule to guide you in adding new resources, actions, and scopes. To add new resources;
 * actions; and scopes, all you should need to do is modify the enums appropriately and fix any
 * resulting type errors.
 *
 * For more info, see: https://github.com/netlify/jigsaw/blob/main/scopes/scopes.go
 *
 * TODO(ndhoule): Generate the ExtensionScope automatically from an OpenAPI schema, from Go source,
 * etc.
 */
/**
 * ExtensionResource is an enum containing resources a user can take action on, like "environment
 * variable".
 *
 * @internal
 */
export var ExtensionResource;
(function (ExtensionResource) {
    ExtensionResource["Blob"] = "blob";
    ExtensionResource["Build"] = "build";
    ExtensionResource["BuildHook"] = "buildhook";
    ExtensionResource["Deploy"] = "deploy";
    ExtensionResource["Dns"] = "dns";
    ExtensionResource["Env"] = "env";
    ExtensionResource["Form"] = "form";
    ExtensionResource["Hook"] = "hook";
    ExtensionResource["LogDrain"] = "logdrain";
    ExtensionResource["Site"] = "site";
    ExtensionResource["User"] = "user";
    /**
     * @deprecated This resource only exists for v1 extension support
     */
    ExtensionResource["Extension"] = "extension";
})(ExtensionResource || (ExtensionResource = {}));
/**
 * ExtensionResource is an enum containing actions a user can take on resources, like "read" or
 * "write".
 *
 * @internal
 */
export var ExtensionAction;
(function (ExtensionAction) {
    ExtensionAction["Read"] = "read";
    ExtensionAction["Write"] = "write";
    ExtensionAction["Delete"] = "delete";
})(ExtensionAction || (ExtensionAction = {}));
/**
 * An enum containing all extension permission scopes. These scopes are primarily used to restrict
 * interactions with the Netlify API (Bitballoon).
 *
 * @internal
 */
export var ExtensionScope;
(function (ExtensionScope) {
    /* eslint-disable @typescript-eslint/prefer-literal-enum-member */
    ExtensionScope["BlobRead"] = "blob:read";
    ExtensionScope["BlobWrite"] = "blob:write";
    ExtensionScope["BlobDelete"] = "blob:delete";
    ExtensionScope["BuildRead"] = "build:read";
    ExtensionScope["BuildWrite"] = "build:write";
    ExtensionScope["BuildHookRead"] = "buildhook:read";
    ExtensionScope["BuildHookWrite"] = "buildhook:write";
    ExtensionScope["BuildHookDelete"] = "buildhook:delete";
    ExtensionScope["DeployRead"] = "deploy:read";
    ExtensionScope["DeployWrite"] = "deploy:write";
    ExtensionScope["DeployDelete"] = "deploy:delete";
    ExtensionScope["DnsRead"] = "dns:read";
    ExtensionScope["HookRead"] = "hook:read";
    ExtensionScope["HookWrite"] = "hook:write";
    ExtensionScope["HookDelete"] = "hook:delete";
    ExtensionScope["EnvRead"] = "env:read";
    ExtensionScope["EnvWrite"] = "env:write";
    ExtensionScope["EnvDelete"] = "env:delete";
    ExtensionScope["FormRead"] = "form:read";
    ExtensionScope["FormDelete"] = "form:delete";
    ExtensionScope["LogDrainRead"] = "logdrain:read";
    ExtensionScope["LogDrainWrite"] = "logdrain:write";
    ExtensionScope["LogDrainDelete"] = "logdrain:delete";
    ExtensionScope["SiteRead"] = "site:read";
    ExtensionScope["SiteWrite"] = "site:write";
    ExtensionScope["UserRead"] = "user:read";
    ExtensionScope["UserWrite"] = "user:write";
    /**
     * @deprecated This scope only exists for v1 extension support. It's used by v2 extensions in the
     * enable flow, but the permissions it grants are not required to enable a v2 extension.
     */
    ExtensionScope["EnableExtension"] = "enable";
    /* eslint-enable @typescript-eslint/prefer-literal-enum-member */
})(ExtensionScope || (ExtensionScope = {}));
const DEPRECATED_SCOPES = new Set([ExtensionScope.EnableExtension]);
const isScopeDeprecated = (scope) => DEPRECATED_SCOPES.has(scope);
const identity = (value) => value;
/**
 * listExtensionScopes returns a list of all extension scope values.
 *
 * By default, deprecated scopes are filtered out.
 *
 * @internal
 */
export const listExtensionScopes = ({ includeDeprecated = false, } = {}) => {
    const scopes = Object.values(ExtensionScope);
    return scopes
        .filter(includeDeprecated ? identity : (scope) => !isScopeDeprecated(scope))
        .sort();
};
/**
 * humanizeExtensionResource formats a scope resource into a human-readable label.
 *
 * @internal
 */
export const humanizeExtensionResource = (resource) => {
    switch (resource) {
        case ExtensionResource.Blob:
            return "Blob";
        case ExtensionResource.Build:
            return "Build";
        case ExtensionResource.Deploy:
            return "Deploy";
        case ExtensionResource.Dns:
            return "Site DNS";
        case ExtensionResource.Env:
            return "Environment variable";
        case ExtensionResource.Form:
            return "Form";
        case ExtensionResource.Hook:
            return "Webhook";
        case ExtensionResource.BuildHook:
            return "Build hook";
        case ExtensionResource.LogDrain:
            return "Log drain";
        case ExtensionResource.Site:
            return "Site";
        case ExtensionResource.User:
            return "User";
        case ExtensionResource.Extension:
            return "Extension";
    }
};
/**
 * humanizeExtensionAction formats a scope action into a human-readable label.
 *
 * @internal
 */
export const humanizeExtensionAction = (action) => {
    switch (action) {
        case ExtensionAction.Read:
            return "Read";
        case ExtensionAction.Write:
            return "Write";
        case ExtensionAction.Delete:
            return "Delete";
    }
};
/**
 * parseExtensionScopeToResourceAndAction splits an extension scope into its resource (e.g. env) and
 * action (e.g. write) components.
 *
 * It's useful for e.g. grouping scopes by resource for display in a UI.
 *
 * Throws an error on failure to parse the scope (though it should only throw when there's a bug in
 * its implementation).
 *
 * @internal
 */
export const parseExtensionScopeToResourceAndAction = (scope) => {
    const parts = scope.split(":");
    if (parts.length !== 2) {
        throw new Error(`Failed to split scope ${scope} into resource:action tuple`);
    }
    return parts;
};
/**
 * deserializeExtensionScopes transforms a serialized list of scopes into an array of
 * ExtensionScopes. Throws if the list is malformed or contains invalid scopes.
 *
 * @internal
 */
export const deserializeExtensionScopes = (value) => {
    const parts = value.split(",").map((part) => part.trim());
    const invalidScopes = parts.filter((part) => !isValidExtensionScope(part));
    if (invalidScopes.length) {
        throw new Error(`Invalid scope(s): ${invalidScopes.map((invalidScope) => `"${invalidScope}"`).join(", ")}`);
    }
    return parts.filter((part) => isValidExtensionScope(part));
};
/**
 * serializeExtensionScopes serializes a list of extension scopes into a format suitable for
 * consumption by the Jigsaw API.
 *
 * @internal
 */
export const serializeExtensionScopes = (scopes) => scopes.slice().sort().join(",");
const ALL_EXTENSION_SCOPES = new Set(listExtensionScopes({ includeDeprecated: true }));
/**
 * isValidExtensionScope checks if a given value is a valid ExtensionScope.
 *
 * @internal
 */
export const isValidExtensionScope = (value) => typeof value === "string" && ALL_EXTENSION_SCOPES.has(value);
const getExtensionScopeResourceRank = (action) => {
    switch (action) {
        case ExtensionResource.Site:
            return 1;
        case ExtensionResource.Env:
            return 2;
        case ExtensionResource.User:
            return 3;
        case ExtensionResource.Build:
            return 4;
        case ExtensionResource.Deploy:
            return 5;
        case ExtensionResource.Hook:
            return 6;
        case ExtensionResource.BuildHook:
            return 7;
        case ExtensionResource.Blob:
            return 8;
        case ExtensionResource.Form:
            return 9;
        case ExtensionResource.LogDrain:
            return 10;
        case ExtensionResource.Dns:
            return 11;
        case ExtensionResource.Extension:
            return 1000;
    }
};
/**
 * extensionResourceComparator is a function that can be used with Array.prototype.sort to sort
 * resources in a predictable order.
 *
 * It's mainly useful for rendering scopes in a stable order in a UI.
 *
 * @internal
 */
export const extensionResourceComparator = (resourceA, resourceB) => {
    const a = getExtensionScopeResourceRank(resourceA);
    const b = getExtensionScopeResourceRank(resourceB);
    if (a === b) {
        return 0;
    }
    return a < b ? -1 : 1;
};
const getExtensionScopeActionRank = (action) => {
    switch (action) {
        case ExtensionAction.Read:
            return 1;
        case ExtensionAction.Write:
            return 2;
        case ExtensionAction.Delete:
            return 3;
    }
};
/**
 * extensionActionComparator is a function that can be used with Array.prototype.sort to sort
 * actions in a predictable order.
 *
 * It's mainly useful for rendering scopes in a stable order in a UI.
 *
 * @internal
 */
export const extensionActionComparator = (actionA, actionB) => {
    const a = getExtensionScopeActionRank(actionA);
    const b = getExtensionScopeActionRank(actionB);
    if (a === b) {
        return 0;
    }
    return a < b ? -1 : 1;
};
/**
 * extensionActionComparator is a function that can be used with Array.prototype.sort to sort
 * scopes in a predictable order.
 *
 * It's mainly useful for rendering scopes in a stable order in a UI.
 *
 * @internal
 */
export const extensionScopeComparator = (scopeA, scopeB) => {
    const [resourceA, actionA] = parseExtensionScopeToResourceAndAction(scopeA);
    const [resourceB, actionB] = parseExtensionScopeToResourceAndAction(scopeB);
    const resourceSort = extensionResourceComparator(resourceA, resourceB);
    if (resourceSort !== 0) {
        return resourceSort;
    }
    // Use action to tiebreak when a and b refer to the same resource
    return extensionActionComparator(actionA, actionB);
};
//# sourceMappingURL=scopes.js.map